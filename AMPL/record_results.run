let curtime := time();


shell("if [ -f " & solution_times_path & " ]; then echo 1 > file_exists.txt; else echo 0 > file_exists.txt; fi");
read file_exists < "file_exists.txt";
close "file_exists.txt";
shell("rm file_exists.txt");
if ( file_exists == 0 )
then {
  printf "scenario_id	carbon_cost	process_type time_seconds\n"
  > (solution_times_path);
  close (solution_times_path);
}
# Store solution times
if ( cost_sol_time >= 0 ) then {
	printf "%d	%d	%s	%d\n", scenario_id, carbon_cost, "Cost_Optimization", cost_sol_time  >> (solution_times_path);
	printf "%d	%d	%s	%d\n", scenario_id, carbon_cost, "Transmission_Optimization", trans_sol_time  >> (solution_times_path);
	close (solution_times_path);
}

#######################
# store all hourly generation data in standardized, MW terms

# hourly power production from each source
# as well as total CO2 emissions per hour, heat rate, variable costs per MWh
# It might be better to report sub-components (CO2_per_mwh, variable_o_m and fuel_cost_hourly) instead of total emissions and variable costs
# (that would simplify the code here, but then the components would have to be multiplied and added in mysql later)
let output_section := 'dispatch';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	date	hour	technology_id	technology	location_id	new	baseload	cogen	fuel	power	co2_tons	hours_in_sample	heat_rate	fuel_cost	carbon_cost_hourly	variable_o_m\n"
  > (outfile);

# new dispatchable projects
printf {(pid, a, t) in PROJ_DISPATCH, h in TIMEPOINTS: DispatchGen[pid, a, t, h] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], pid, load_area_id[a], a, date[h], h, technology_id[t], t, location_unspecified, 1, 0, 0, fuel[t], 
  DispatchGen[pid, a, t, h], 
  DispatchGen[pid, a, t, h] * heat_rate[t] * carbon_content[fuel[t]],
  hours_in_sample[h],
  heat_rate[t], 
  DispatchGen[pid, a, t, h] * heat_rate[t] * fuel_cost_hourly[a, fuel[t], h],
  DispatchGen[pid, a, t, h] * heat_rate[t] * carbon_content[fuel[t]] * carbon_cost,
  DispatchGen[pid, a, t, h] * variable_o_m[pid, a, t]
  >> (outfile);

# new baseload plants
printf {(pid, a, t) in PROJECTS, h in TIMEPOINTS: 
	new_baseload[t] and (sum{(pid, a, t, install_yr) in NEW_BASELOAD_VINTAGES} InstallGen[pid, a, t, install_yr]) > 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], pid, load_area_id[a], a, date[h], h, technology_id[t], t, location_unspecified, 1, new_baseload[t], 0, fuel[t],
  (sum{(pid, a, t, install_yr, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * ( 1 - scheduled_outage_rate[t] ) ),
  (sum{(pid, a, t, install_yr, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * ( 1 - scheduled_outage_rate[t] ) ) 
    * heat_rate[t] * carbon_content[fuel[t]],
  hours_in_sample[h],
  heat_rate[t], 
  (sum{(pid, a, t, install_yr, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * ( 1 - scheduled_outage_rate[t] ) ) 
    * heat_rate[t] * fuel_cost_hourly[a,fuel[t], h],
  (sum{(pid, a, t, install_yr, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * ( 1 - scheduled_outage_rate[t] ) ) 
    * heat_rate[t] * carbon_content[fuel[t]] * carbon_cost,
  (sum{(pid, a, t, install_yr, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * ( 1 - scheduled_outage_rate[t] ) ) 
    * variable_o_m[pid, a, t]
  >> (outfile);

# new intermittent projects (all renewables, so no carbon emissions)
printf {(pid, a, t, h) in PROJ_INTERMITTENT_HOURS:
		(sum {(pid, a, t, install_yr, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} InstallGen[pid, a, t, install_yr]) != 0 and cap_factor[pid, a, t, h] != 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.2f\n",
  scenario_id, carbon_cost, period[h], pid, load_area_id[a], a, date[h], h, technology_id[t], t, project_location[pid, a, t], 1, 0, 0, fuel[t], 
  (sum {(pid, a, t, install_yr, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * cap_factor[pid, a, t, h] ),
  0,
  hours_in_sample[h],
  0, 
  0, 0,
  (sum {(pid, a, t, install_yr, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    InstallGen[pid, a, t, install_yr] * ( 1 - forced_outage_rate[t] ) * cap_factor[pid, a, t, h] ) * variable_o_m[pid, a, t]
  >> (outfile);


# existing dispatchable plants
printf {(a, e, h) in EP_DISPATCH_HOURS, p in PERIODS: p=period[h] and DispatchEP[a, e, h] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[a, e], load_area_id[a], a, date[h], h, technology_id[ep_technology[a,e]], ep_technology[a,e], e, 0, ep_baseload[a, e], ep_cogen[a, e], ep_fuel[a, e],
  DispatchEP[a, e, h],
  DispatchEP[a, e, h] * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]],
  hours_in_sample[h],
  ep_heat_rate[a, e], 
  DispatchEP[a, e, h]
    * ep_heat_rate[a, e] * fuel_cost_hourly[a, ep_fuel[a, e], h],
  DispatchEP[a, e, h]
    * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]] * carbon_cost,
  DispatchEP[a, e, h]
    * ep_variable_o_m[a, e]
  >> (outfile);

# Existing Intermittent plants
printf {(a, e, h) in EP_INTERMITTENT_OPERATIONAL_HOURS, p in PERIODS: period[h]=p and OperateEPDuringPeriod[a, e, p] != 0 and eip_cap_factor[a, e, h] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[a, e], load_area_id[a], a, date[h], h, technology_id[ep_technology[a,e]], ep_technology[a,e], e, 0, ep_baseload[a, e], ep_cogen[a, e], ep_fuel[a, e],
  # Power
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * eip_cap_factor[a, e, h] * (1-ep_forced_outage_rate[a, e]), 
  # Co2 (tons)
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * eip_cap_factor[a, e, h] * (1-ep_forced_outage_rate[a, e])
    * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]],
  # hours_in_sample
  hours_in_sample[h],
  # heat_rate
  ep_heat_rate[a, e], 
  # fuel_cost_tot
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * eip_cap_factor[a, e, h] * (1-ep_forced_outage_rate[a, e])
    * ep_heat_rate[a, e] * fuel_cost_hourly[a,ep_fuel[a, e], h],
  # carbon_cost_tot
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * eip_cap_factor[a, e, h] * (1-ep_forced_outage_rate[a, e])
    * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]] * carbon_cost,
  # variable_o_m_tot
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * eip_cap_factor[a, e, h] * (1-ep_forced_outage_rate[a, e])
    * ep_variable_o_m[a, e]
  >> (outfile);

# existing baseload plants
printf {(a, e, p) in EP_BASELOAD_PERIODS, h in TIMEPOINTS: period[h]=p and OperateEPDuringPeriod[a, e, p] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[a, e], load_area_id[a], a, date[h], h, technology_id[ep_technology[a,e]], ep_technology[a,e], e, 0, ep_baseload[a, e], ep_cogen[a, e], ep_fuel[a, e],
  OperateEPDuringPeriod[a, e, p] * (1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e],
  OperateEPDuringPeriod[a, e, p] * (1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e] 
    * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]],
  hours_in_sample[h],
  ep_heat_rate[a, e], 
  OperateEPDuringPeriod[a, e, p] * (1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e] 
    * ep_heat_rate[a, e] * fuel_cost_hourly[a,ep_fuel[a, e], h],
  OperateEPDuringPeriod[a, e, p] * (1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e] 
    * ep_heat_rate[a, e] * carbon_content[ep_fuel[a, e]] * carbon_cost,
  OperateEPDuringPeriod[a, e, p] * (1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e]
    * ep_variable_o_m[a, e]
  >> (outfile);

# To do: Update hydro cost numbers and distinguish costs of pumped and non-pumped

# Dispatch of non-pumped hydro. 
printf {(a, pid) in PROJ_NONPUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS: period[h]=p and Dispatch_NonPumped_Hydro[a, pid, h] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, date[h], h, hydro_technology_id[a,pid,date[h]], "Hydro_NonPumped", "Hydro_Agg", 0, 0, 0,
  fuel_hydro, Dispatch_NonPumped_Hydro[a, pid, h],
  0, hours_in_sample[h], 0, 
  0, 0, 
  Dispatch_NonPumped_Hydro[a, pid, h] * economic_multiplier[a] * hydro_var_o_m
  >> (outfile);

# Dispatch of pumped hydro watershed electrons. 
printf {(a, pid) in PROJ_PUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS: period[h]=p and Dispatch_Pumped_Hydro_Watershed_Electrons[a, pid, h] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, date[h], h, hydro_technology_id[a,pid,date[h]], "Hydro_Pumped", "Hydro_Agg", 0, 0, 0,
  fuel_hydro, Dispatch_Pumped_Hydro_Watershed_Electrons[a, pid, h],
  0, hours_in_sample[h], 0, 
  0, 0, 
  Dispatch_Pumped_Hydro_Watershed_Electrons[a, pid, h] * economic_multiplier[a] * hydro_var_o_m
  >> (outfile);

close (outfile);

#######################
# Store all STORAGE DISPATCH decisions

let output_section := 'storage_dispatch';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	date	hour	technology_id	technology	storage_efficiency	new	fuel_category	hours_in_sample	power variable_o_m_cost\n"
  > (outfile);

# Storage of pumped hydro.
printf {(a, pid) in PROJ_PUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS, fc in RPS_FUEL_CATEGORY: period[h]=p and Store_Pumped_Hydro[a, pid, h, fc] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%.4f	%d	%s	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, date[h], h, hydro_technology_id[a,pid,date[h]], "Hydro_Pumped", pumped_hydro_efficiency, 0,
  fc, hours_in_sample[h], -1 * Store_Pumped_Hydro[a, pid, h, fc],
  # Don't have to pay for storing pumped hydro at the moment
  0
  >> (outfile);

# Dispatch of stored pumped hydro.
printf {(a, pid) in PROJ_PUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS, fc in RPS_FUEL_CATEGORY: period[h]=p and Dispatch_Pumped_Hydro_Storage[a, pid, h, fc] != 0} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%.4f	%d	%s	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, date[h], h, hydro_technology_id[a,pid,date[h]], "Hydro_Pumped", pumped_hydro_efficiency, 0,
  fc, hours_in_sample[h], Dispatch_Pumped_Hydro_Storage[a, pid, h, fc],
  # Don't have to pay for storing pumped hydro at the moment
  0
  >> (outfile);

close (outfile);


#######################
# store all generation CAPACITY data in standardized, MW terms
# (these are quoted as total capacity installed up through each study period)

let output_section := 'generation_capacity';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	technology_id	technology	site	new	baseload	cogen	fuel	capacity	capital_cost	fixed_o_m_cost\n"
> (outfile);

# new projects INTERMITTENT
printf {(pid, a, t) in PROJ_INTERMITTENT union PROJ_RESOURCE_LIMITED, p in PERIODS: (max {(pid, a, t, install_yr) in PROJECT_VINTAGES} InstallGen[pid, a, t, install_yr]) > 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, technology_id[t], t, project_location[pid, a, t], 1, new_baseload[t], 0, fuel[t],
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr],
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr]
    * (capital_cost_annual_payment[pid, a, t,install_yr]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr]
    * (fixed_o_m[pid, a, t]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

# new projects DISPATCHABLE & BASELOAD
printf {(pid, a, t) in PROJ_ANYWHERE, p in PERIODS: (max {(pid, a, t, install_yr) in PROJECT_VINTAGES} InstallGen[pid, a, t, install_yr]) > 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, technology_id[t], t, location_unspecified, 1, new_baseload[t], 0, fuel[t],
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr],
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr]
    * (capital_cost_annual_payment[pid, a, t,install_yr]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,
  sum {(pid, a, t, install_yr) in PROJECT_VINTAGES: install_yr <= p < project_end_year[t, install_yr]} InstallGen[pid, a, t, install_yr]
    * (fixed_o_m[pid, a, t]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

# existing plants (either baseload or dispatchable)
# note: they're only counted as "capacity" if they are operable during this period
# as cogen plants can have their life extended past ep_end_year,
# their capital cost are included here only if they are operated past their normal lifetime (the second printf statement - could probably done in one statement with an in-line if)
printf {(a, e, p) in EP_PERIODS: p < ep_end_year[a, e] }
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[a, e], load_area_id[a], a, technology_id[ep_technology[a,e]], ep_technology[a,e], e, 0, ep_baseload[a, e], ep_cogen[a, e], ep_fuel[a, e],
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e],
  # Capital costs
  ep_size_mw[a, e] * ep_capital_cost_annual_payment[a, e] *
    (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,
  # Fixed O & M
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * ep_fixed_o_m[a, e] * economic_multiplier[a] *
    (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

# Existing plants that are kept online or replaced past the point of retirement...
# This is currently only used for site-specific cogen facilities because all other major types of existing plants can be replaced with new facilities. We may later extend this to include other existing site-specific plants such as geothermal.
printf { (a, e, p) in EP_PERIODS: ep_cogen[a, e] and p >= ep_end_year[a, e] }
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[a, e], load_area_id[a], a, technology_id[ep_technology[a,e]], ep_technology[a,e], e, 0, ep_baseload[a, e], ep_cogen[a, e], ep_fuel[a, e],
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e],
  # Capital costs
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * ep_capital_cost_annual_payment[a, e] *
    (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,
  # Fixed O & M
  OperateEPDuringPeriod[a, e, p] * ep_size_mw[a, e] * ep_fixed_o_m[a, e] * economic_multiplier[a] *
    (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);


# hydro plants (non-pumped)
# note: capacity is defined as the maximum possible output on any date in the period
# Fixed costs are based on the hydro_annual_payment_per_mw parameter that is set and explained in windsun.dat. It is reported in terms of re-occurring costs due at the beginning of each study period.
printf {(a, pid) in PROJ_NONPUMPED_HYDRO, p in PERIODS}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, hydro_technology_id[a,pid,first(DATES)], "Hydro_NonPumped", "Hydro_Agg", 0, 0, 0, fuel_hydro,
  max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d],
   # CAPITAL cost
	(max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d])          # MW installed
	* hydro_capital * economic_multiplier[a]                                      # Regional annual costs per MW
	* (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,             # Convert annual payments to a lump sum at the start of the study period
  # fixed O & M cost
  	(max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d])          # MW installed
  	* hydro_fixed_o_m * economic_multiplier[a]                                    # Regional annual costs per MW
  	* (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate              # Convert annual payments to a lump sum at the start of the study period
  >> (outfile);

# hydro plants (pumped)
printf {(a, pid) in PROJ_PUMPED_HYDRO, p in PERIODS}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, hydro_technology_id[a,pid,first(DATES)], "Hydro_Pumped", "Hydro_Agg", 0, 0, 0, fuel_hydro,
  max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d],
  # CAPITAL cost
  (max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d])          # Estimate of MW installed
  * hydro_capital * economic_multiplier[a]                                      # Regional annual costs per MW
  * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate,             # Convert annual payments to a lump sum at the start of the study period
  # fixed O & M cost
  (max {(a, pid, d) in PROJ_HYDRO_DATES} hydro_capacity_mw[a, pid, d])          # Estimate of MW installed
  * hydro_fixed_o_m * economic_multiplier[a]                                    # Regional annual costs per MW
  * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate              # Convert annual payments to a lump sum at the start of the study period
  >> (outfile);

close (outfile);

########################
# store all trans capacity between zones
let output_section := 'transmission_capacity';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	transmission_line_id	start_id	end_id	start	end	new	trans_mw	fixed_cost\n"
  > (outfile);

# existing lines
# the cost of the existing transmission grid is calculated in the param transmission_sunk_cost and is not included here because it includes all lines, not just the lines between load areas
printf {(z1, z2) in TRANSMISSION_LINES, p in PERIODS}:
  "%s	%.2f	%d	%d	%d	%d	%s	%s	%d	%.2f	%d\n",
  scenario_id, carbon_cost, p, transmission_line_id[z1, z2], load_area_id[z1], load_area_id[z2], z1, z2, 0, (existing_transfer_capacity_mw[z1, z2]), 0
  >> (outfile);

# new lines
printf {(z1, z2) in TRANSMISSION_LINES, p in PERIODS}:
  "%s	%.2f	%d	%d	%d	%d	%s	%s	%d	%.2f	%d\n",
  scenario_id, carbon_cost, p, transmission_line_id[z1, z2], load_area_id[z1], load_area_id[z2], z1, z2, 1, 
  sum {install_yr in PERIODS: install_yr <= p < transmission_end_year[install_yr]} InstallTrans[z1, z2, install_yr],
  (sum {install_yr in PERIODS: install_yr <= p < transmission_end_year[install_yr]} InstallTrans[z1, z2, install_yr] * transmission_annual_payment[z1, z2, install_yr])
     * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

close (outfile);

#######################
# store hourly TRANSMISSION decisions in standardized, MW terms

let output_section := 'transmission_dispatch';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	transmission_line_id	load_area_receive_id	load_area_from_id	load_area_receive	load_area_from	date	hour	rps_fuel_category	power_sent	power_received	hours_in_sample\n"
  > (outfile);

# detailed imports & exports
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf {(x, y) in TRANSMISSION_LINES, h in TIMEPOINTS, fuel_cat in RPS_FUEL_CATEGORY: DispatchTransFromXToY[x, y, h, fuel_cat] > 0.001} 
  "%s	%.2f	%d	%d	%d	%d	%s	%s	%d	%d	%s	%.2f	%.2f	%d\n",
  scenario_id, carbon_cost, period[h], transmission_line_id[x, y], load_area_id[y], load_area_id[x], y, x, date[h], h, fuel_cat,
  DispatchTransFromXToY[x, y, h, fuel_cat],
  DispatchTransFromXToY[x, y, h, fuel_cat] * transmission_efficiency[x, y],
  hours_in_sample[h]
  >> (outfile);
close (outfile);

########################
# store the costs of all existing transmission capacity
let output_section := 'existing_trans_cost';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	load_area_id	load_area	fixed_cost\n"
  > (outfile);

printf {p in PERIODS, a in LOAD_AREAS}:
  "%s	%.2f	%d	%d	%s	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[a], a,
  transmission_sunk_annual_payment[a]
  * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

close (outfile);

########################
# store local T&D capacity within each zone
let output_section := 'local_td_capacity';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	load_area_id	load_area	new local_td_mw	fixed_cost\n"
  > (outfile);

# existing local T&D - assumed to be equal to the planning reserve margin above max_coincident_load_for_local_td 
printf {p in PERIODS, a in LOAD_AREAS}:
  "%s	%.2f	%d	%d	%s	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[a], a, 0,
  existing_local_td[a],
  local_td_sunk_annual_payment[a]
  * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

# newly installed local T&D
printf {p in PERIODS, a in LOAD_AREAS}:
  "%s	%.2f	%d	%d	%s	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[a], a, 1,
  sum {install_yr in PERIODS: install_yr <= p < local_td_end_year[install_yr]} InstallLocalTD[a, install_yr],
  (sum {install_yr in PERIODS: install_yr <= p < local_td_end_year[install_yr]} InstallLocalTD[a, install_yr])
    * local_td_new_annual_payment_per_mw[a] * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

close (outfile);


#######################
# system LOAD
let output_section := 'system_load';
let outfile := sprintf( result_file_path_templates[output_section], carbon_cost );
printf "scenario_id	carbon_cost	period	load_area_id	load_area	date	hour	power	hours_in_sample\n"
  > (outfile);

printf {a in LOAD_AREAS, h in TIMEPOINTS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%s	%d	%d	%.2f	%d\n",
  scenario_id, carbon_cost, p, load_area_id[a], a, date[h], h, system_load[a, h], hours_in_sample[h]
  >> (outfile);
close (outfile);


printf "%d seconds to store results.\n", time()-curtime;
