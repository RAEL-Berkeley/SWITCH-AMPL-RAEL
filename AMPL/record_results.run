let curtime := time();


#######################
# store all hourly generation data in standardized, MW terms

# hourly power production from each source
# as well as total CO2 emissions per hour, heat rate, variable costs per MWh
# It might be better to report sub-components (CO2_per_mwh, variable_o_m and fuel_cost_hourly) instead of total emissions and variable costs
# (that would simplify the code here, but then the components would have to be multiplied and added in mysql later)
let outfile := "results/dispatch_columns.txt";
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	date	hour	technology_id	technology	location_id	new	baseload	cogen	fuel	power	co2_tons	hours_in_sample	heat_rate	fuel_cost_tot	carbon_cost_tot	variable_o_m_tot\n"
  > (outfile);
close (outfile);

# new dispatchable projects
let outfile := "results/dispatch_" & carbon_cost & ".txt";
printf {(z, t, p) in PROJ_DISPATCH, h in TIMEPOINTS} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], regional_project_id[z, t], load_area_id[z], z, date[h], h, technology_id[t], t, location_unspecified, 1, 0, 0, fuel[t], 
  DispatchGen[z, t, p, h], 
  DispatchGen[z, t, p, h] * heat_rate[t] * carbon_content[fuel[t]],
  hours_in_sample[h],
  heat_rate[t], 
  DispatchGen[z, t, p, h] * heat_rate[t] * fuel_cost_hourly[z, fuel[t], h],
  DispatchGen[z, t, p, h] * heat_rate[t] * carbon_content[fuel[t]] * carbon_cost,
  DispatchGen[z, t, p, h] * variable_o_m[z,t]
  > (outfile);


# new intermittent projects (all renewables, so no carbon emissions)
printf {(z, t, p, h) in PROJ_INTERMITTENT_HOURS}
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.2f\n",
  scenario_id, carbon_cost, period[h], p, load_area_id[z], z, date[h], h, technology_id[t], t, location_id[z, t, p], 1, 0, 0, fuel[t], 
  (sum {(z, t, p, v, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * cap_factor[z, t, p, h] * InstallGen[z, t, p, v]),
  0,
  hours_in_sample[h],
  0, 
  0, 0,
  (sum {(z, t, p, v, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * cap_factor[z, t, p, h] * InstallGen[z, t, p, v]) * variable_o_m[z,t]
  >> (outfile);

# new baseload plants
# 
printf {(z, t, p) in setof{(z, t, p, v) in PROJECT_VINTAGES} (z, t, p), h in TIMEPOINTS}
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], regional_project_id[z, t], load_area_id[z], z, date[h], h, technology_id[t], t, location_unspecified, 1, new_baseload[t], 0, fuel[t],
  (sum{(z, t, p, v, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * InstallGen[z, t, p, v]),
  (sum{(z, t, p, v, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * InstallGen[z, t, p, v]) 
    * heat_rate[t] * carbon_content[fuel[t]],
  hours_in_sample[h],
  heat_rate[t], 
  (sum{(z, t, p, v, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * InstallGen[z, t, p, v]) 
    * heat_rate[t] * fuel_cost_hourly[z,fuel[t], h],
  (sum{(z, t, p, v, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * InstallGen[z, t, p, v]) 
    * heat_rate[t] * carbon_content[fuel[t]] * carbon_cost,
  (sum{(z, t, p, v, h) in NEW_BASELOAD_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * InstallGen[z, t, p, v])
    * variable_o_m[z, t]
  >> (outfile);

# Existing Intermittent plants
# 
printf {(z, e, h) in EP_INTERMITTENT_OPERATIONAL_HOURS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[z, e], load_area_id[z], z, date[h], h, technology_id[ep_technology[z,e]], ep_technology[z,e], e, 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  # Power
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * eip_cap_factor[z, e, h] * (1-ep_forced_outage_rate[z, e]), 
  # Co2 (tons)
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * eip_cap_factor[z, e, h] * (1-ep_forced_outage_rate[z, e])
    * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]],
  # hours_in_sample
  hours_in_sample[h],
  # heat_rate
  ep_heat_rate[z, e], 
  # fuel_cost_tot
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * eip_cap_factor[z, e, h] * (1-ep_forced_outage_rate[z, e])
    * ep_heat_rate[z, e] * fuel_cost_hourly[z,ep_fuel[z, e], h],
  # carbon_cost_tot
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * eip_cap_factor[z, e, h] * (1-ep_forced_outage_rate[z, e])
    * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]] * carbon_cost,
  # variable_o_m_tot
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * eip_cap_factor[z, e, h] * (1-ep_forced_outage_rate[z, e])
    * ep_variable_o_m[z, e]
  >> (outfile);


# existing baseload plants
printf {(z, e, p) in EP_BASELOAD_PERIODS, h in TIMEPOINTS: period[h]=p} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[z, e], load_area_id[z], z, date[h], h, technology_id[ep_technology[z,e]], ep_technology[z,e], e, 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  OperateEPDuringPeriod[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e],
  OperateEPDuringPeriod[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]],
  hours_in_sample[h],
  ep_heat_rate[z, e], 
  OperateEPDuringPeriod[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e] * fuel_cost_hourly[z,ep_fuel[z, e], h],
  OperateEPDuringPeriod[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]] * carbon_cost,
  OperateEPDuringPeriod[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e]
    * ep_variable_o_m[z, e]
  >> (outfile);

# existing dispatchable plants
printf {(z, e, h) in EP_DISPATCH_HOURS, p in PERIODS: p=period[h]} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%d	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[z, e], load_area_id[z], z, date[h], h, technology_id[ep_technology[z,e]], ep_technology[z,e], e, 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  DispatchEP[z, e, h],
  DispatchEP[z, e, h] * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]],
  hours_in_sample[h],
  ep_heat_rate[z, e], 
  DispatchEP[z, e, h]
    * ep_heat_rate[z, e] * fuel_cost_hourly[z, ep_fuel[z, e], h],
  DispatchEP[z, e, h]
    * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]] * carbon_cost,
  DispatchEP[z, e, h]
    * ep_variable_o_m[z, e]
  >> (outfile);

# Dispatch of non-pumped hydro. In the results database, Hydro has a hard-coded id of 15, and Hydro Pumping has 16 (see DatabasePrep/GeneratorInfo/generator_costs.csv)
printf {(z, proj) in PROJ_NONPUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.0f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, date[h], h, 15, "Hydro_NonPumped", hydro_site[z, proj, first(DATES)], 0, 0, 0,
  fuel_hydro, (1 - forced_outage_rate_hydro) * DispatchHydro[z, proj, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# Dispatch of pumped hydro. 
printf {(z, proj) in PROJ_PUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.0f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, date[h], h, 16, "Hydro_Pumped", hydro_site[z, proj, first(DATES)], 0, 0, 0,
  fuel_hydro, (1 - forced_outage_rate_hydro) * DispatchHydro[z, proj, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# Storage of pumped hydro.
printf {(z, proj) in PROJ_PUMPED_HYDRO, h in TIMEPOINTS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%d	%s	%d	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f	%d	%.0f	%.0f	%.0f	%.0f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, date[h], h, 16, "Hydro_Pumped", hydro_site[z, proj, first(DATES)], 0, 0, 0, fuel_hydro,
  -1 * (1 - forced_outage_rate_hydro) * (1/pumped_hydro_efficiency) * StorePumpedHydro[z, proj, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

close (outfile);



#######################
# system load
let outfile := "results/sys_load_columns.txt";
printf "scenario_id	carbon_cost	period	load_area_id	load_area	date	hour	power\n"
  > (outfile);
close (outfile);
let outfile := "results/system_load_" & carbon_cost & ".txt";
printf {z in LOAD_AREAS, h in TIMEPOINTS, p in PERIODS: period[h]=p} 
  "%s	%.2f	%d	%d	%s	%d	%d	%.2f	%d\n",
  scenario_id, carbon_cost, p, load_area_id[z], z, date[h], h, system_load[z, h], hours_in_sample[h]
  > (outfile);
close (outfile);



#######################
# store detailed transmission info in standardized, MW terms

let outfile := "results/transmission_columns.txt";
printf "scenario_id	carbon_cost	period	load_area_receive_id	load_area_from_id	load_area_receive	load_area_from	date	hour	rps_fuel_category	power_sent	power_received	hours_in_sample\n"
  > (outfile);
close (outfile);


# detailed imports & exports
let outfile := "results/transmission_" & carbon_cost & ".txt";
printf {(x, y) in TRANSMISSION_LINES, h in TIMEPOINTS, fuel_cat in RPS_FUEL_CATEGORY: DispatchTransFromXToY[x, y, h, fuel_cat] > 0.001} 
  "%s	%.2f	%d	%d	%d	%s	%s	%d	%d	%s	%.2f	%.2f	%d\n",
  scenario_id, carbon_cost, period[h], load_area_id[y], load_area_id[x], y, x, date[h], h, fuel_cat,
  DispatchTransFromXToY[x, y, h, fuel_cat],
  DispatchTransFromXToY[x, y, h, fuel_cat] * transmission_efficiency[x, y],
  hours_in_sample[h]
  > (outfile);
close (outfile);


#######################
# store all gen/trans capacity data in standardized, MW terms
# (these are quoted as total capacity installed up through each study period)

let outfile := "results/gen_cap_columns.txt";
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	technology_id	technology	site	new	baseload	cogen	fuel	capacity	fixed_cost\n" > (outfile);
close (outfile);

let outfile := "results/gen_cap_" & carbon_cost & ".txt";
# new projects INTERMITTENT
printf {(z, t, proj) in PROJ_INTERMITTENT union PROJ_RESOURCE_LIMITED, p in PERIODS: (max {(z, t, proj, v) in PROJECT_VINTAGES} InstallGen[z, t, proj, v]) > 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, technology_id[t], t, location_id[z, t, proj], 1, new_baseload[t], 0, fuel[t],
  sum {(z, t, proj, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, proj, v],
  sum {(z, t, proj, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, proj, v]
    * (capital_cost_annual_payment[z,t,proj,v] + fixed_o_m[z,t]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  > (outfile);

# new projects DISPATCHABLE & BASELOAD
printf {(z, t, proj) in PROJ_ANYWHERE, p in PERIODS: (max {(z, t, proj, v) in PROJECT_VINTAGES} InstallGen[z, t, proj, v]) > 0}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f\n",
  scenario_id, carbon_cost, proj, regional_project_id[z, t], load_area_id[z], z, technology_id[t], t, location_unspecified, 1, new_baseload[t], 0, fuel[t],
  sum {(z, t, proj, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, proj, v],
  sum {(z, t, proj, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, proj, v]
    * (capital_cost_annual_payment[z,t,proj,v] + fixed_o_m[z,t]) * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  > (outfile);


# existing plants (either baseload or dispatchable)
# note: they're only counted as "capacity" if they are operable during this period
# and baseload plants are assumed to be operable only up to 1-ep_scheduled_outage_rate
printf {(z, e, p) in EP_PERIODS}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[z, e], load_area_id[z], z, technology_id[ep_technology[z,e]], ep_technology[z,e], e, 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] 
    * if ep_baseload[z, e] then (1-ep_scheduled_outage_rate[z, e]) else 1,
  OperateEPDuringPeriod[z, e, p] * ep_size_mw[z, e] * ep_fixed_cost[z, e, p] * (1+discount_rate)^(p-base_year)
  + ep_size_mw[z, e] * ep_capital_cost_annual_payment[z, e] * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

# In the results database, Hydro has a hard-coded id of 15, and Hydro Pumping has 16 (see DatabasePrep/GeneratorInfo/generator_costs.csv)
# hydro plants (non-pumped)
# note: capacity is defined as the maximum possible output on any date in the period
# currently assumed to have no fixed cost; fix this later!
printf {(z, proj) in PROJ_NONPUMPED_HYDRO, p in PERIODS}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, 15, "Hydro_NonPumped", hydro_site[z, proj, first(DATES)], 0, 0, 0, fuel_hydro,
  max {d in DATES, h in TIMEPOINTS: date[h] = d and period[h] = p} max_hydro_flow[z, proj, d],
  0
  >> (outfile);
# hydro plants (pumped)
printf {(z, proj) in PROJ_PUMPED_HYDRO, p in PERIODS}
  "%s	%.2f	%d	%d	%d	%s	%d	%s	%s	%d	%d	%d	%s	%.2f	%.0f\n",
  scenario_id, carbon_cost, p, proj, load_area_id[z], z, 16, "Hydro_Pumped", hydro_site[z, proj, first(DATES)], 0, 0, 0, fuel_hydro,
  max {d in DATES, h in TIMEPOINTS: date[h] = d and period[h] = p} max_hydro_flow[z, proj, d],
  0
  >> (outfile);

close (outfile);

########################
# store all trans capacity between zones
let outfile := "results/trans_cap_columns.txt";
printf "scenario_id	carbon_cost	period	start_id	end_id	start	end	transmission_line_id	new	trans_mw	fixed_cost\n" > (outfile);
close (outfile);

let outfile := "results/trans_cap_" & carbon_cost & ".txt";
# existing lines 
# TODO: update this if the main model is changed to retire existing lines when they reach transmission_max_age_years
# TODO: switch this to record the bidirectional capacities, instead of averaging them together
printf {(z1, z2) in TRANSMISSION_LINES, p in PERIODS}:
  "%s	%.2f	%d	%d	%d	%s	%s	%d	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[z1], load_area_id[z2], z1, z2, transmission_line_id[z1, z2], 0, (existing_transfer_capacity_mw[z1, z2]),
  ((existing_transfer_capacity_mw[z1, z2])) 
    * transmission_annual_payment[z1, z2, first(PERIODS)] * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  > (outfile);

# new lines
printf {(z1, z2) in TRANSMISSION_LINES, p in PERIODS}:
  "%s	%.2f	%d	%d	%d	%s	%s	%d	%d	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[z1], load_area_id[z2], z1, z2, transmission_line_id[z1, z2], 1, 
  sum {v in PERIODS: v <= p < transmission_end_year[v]} InstallTrans[z1, z2, v],
  (sum {v in PERIODS: v <= p < transmission_end_year[v]} InstallTrans[z1, z2, v] * transmission_annual_payment[z1, z2, v])
     * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  >> (outfile);

close (outfile);


########################
# store local T&D capacity within each zone
let outfile := "results/local_td_cap_columns.txt";
printf "scenario_id	carbon_cost	period	load_area_id	load_area	local_td_mw	fixed_cost\n" > (outfile);
close (outfile);

let outfile := "results/local_td_cap_" & carbon_cost & ".txt";
printf {p in PERIODS, z in LOAD_AREAS}:
  "%s	%.2f	%d	%d	%s	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, load_area_id[z], z, 
  sum {v in PERIODS: v <= p < transmission_end_year[v]} InstallLocalTD[z, v],
  (sum {v in PERIODS: v <= p < transmission_end_year[v]} InstallLocalTD[z, v])
    * local_td_annual_payment_per_mw * (1-(1/(1+discount_rate)^(num_years_per_period)))/discount_rate
  > (outfile);

close (outfile);

printf "%d seconds to store results.\n", time()-curtime;
