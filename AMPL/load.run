# June 25th, 2013
# File copied and edited from /Volumes/switch/Models/China/AMPL_Model/load.run
# Edited by Patricia Hidalgo-Gonzalez 


# load.run
# SYNOPSIS
#   include load.run;
# DESCRIPTION
#   Loads the SWITCH model and input data that was exported with get_switch_input_tables.sh. Also sets policy options according to the input scenario.
reset;

############################################################
# Utility Functions that interact with the operating system
# get_num_cores() determines how many processor cores are on the current machine. Works on OS X & Linux.
function get_num_cores pipe "while read junk; do case $(uname) in  'Darwin') sysctl hw.ncpu | awk '{print $2}' ;;  'Linux')  grep processor /proc/cpuinfo | wc -l | awk '{print $1}' ;;  *) echo 1 ;; esac; done";
# file_exists(file_path) determines whether a file exists at the specified path (relative or absolute). Returns a 1 or a 0. Works on OS X & Linux.
function file_exists pipe 'while read file_path; do if [ -f "$file_path" ]; then echo 1; else echo 0; fi; done;';

###################################
# Make directories for results and logs if they don't exist.
param results_path symbolic := 'results/';
param solution_times_path symbolic = "results/run_times.txt";
shell("mkdir -p " & results_path );
shell("mkdir -p logs");
# Make a file header for solution time if it doesn't exist.
if ( file_exists(solution_times_path) == 0 )
then {
  printf "scenario_id	carbon_cost	process_type	completed_at	time_seconds\n"
  > (solution_times_path);
  close (solution_times_path);
}

###################################
# These AMPL & cplex options must be set before the model is included. 
option presolve 0, presolve_eps 1e-10;
# Options to enable automatic substitution of variables without making the program non-linear
option substout 1, linelim 1;
# Options to enable timing of compilation
# option show_stats 1, times 1, gentimes 1;
option solver cplexamp;
option cplex_options (" threads=4 presolve=1 prestats=1 nodefile=2 baropt barobjrange=1e+30 comptol=1e-9 lpdisplay=1 bardisplay=2 timing=1 startalgorithm=4 mipdisplay=4 iisfind=1" );
# Use the option string below to enable iisfind when you are trying to diagnose infeasibilities
#option cplex_options (" lpdisplay=1 iisfind=1 mipdisplay=2 presolve=1 prestats=1 timing=1 nodefile=2 treememory=15000 threads=4" );
option cplex_options > results/cplex_options;
shell('sed -i -e "s/^.*' & "'\(.*\)'" & ';/\1/" results/cplex_options');

# make SWITCH china have default LP runs
option relax_integrality  1;

# Include other AMPL code files. 
model switch.mod;
include define_params.run;
data switch.dat;
data inputs/misc_params.dat;

#########################
# Read in data from tab files exported from postgres by get_switch_input_tablesv5.sh

# PATY: The col regional_grid_company wasn't erased, but for Chile is in blank. la_system is the analogous col.
# PATY: New col rps_compliance_entity, to make rps work.
table load_area "inputs/load_area.tab" IN: 
  LOAD_AREAS <- [la_id], la_system, ccs_distance_km,
  	present_day_existing_distribution_cost, present_day_max_coincident_demand_mwh_for_distribution, distribution_new_annual_payment_per_mw,
  	existing_transmission_sunk_annual_payment, bio_gas_capacity_limit_mmbtu_per_hour, rps_compliance_entity;
read table load_area;

table regional_grid_companies "inputs/regional_grid_companies.tab" IN:
  LA_SYSTEMS <- [la_system], load_only_spinning_reserve_requirement, wind_spinning_reserve_requirement,
    solar_spinning_reserve_requirement, quickstart_requirement_relative_to_spinning_reserve_requirement;
read table regional_grid_companies;

# PATY: TABLE ADDED. NOT SURE IF THIS IS CORRECT FOR THAT SET. I NEED TO MAKE THIS PROPERLY.
table rps_compliance_entity_targets "inputs/rps_compliance_entity_targets.tab" IN: 
  RPS_TARGETS_ALL <- [rps_compliance_entity, rps_compliance_type, rps_compliance_year], rps_compliance_fraction;
read table rps_compliance_entity_targets;
# END PATY TABLE

# PATY: TABLE ADDED.
table rps_areas_and_fuel_category "inputs/rps_areas_and_fuel_category.tab" IN: 
  RPS_AREAS_AND_FUEL_CATEGORY <- [la_id, fuel_category], fuel_qualifies_for_rps;
read table rps_areas_and_fuel_category;
# END PATY TABLE

table carbon_cap_targets "inputs/carbon_cap_targets.tab" IN: 
  [year], carbon_emissions_relative_to_base;
read table carbon_cap_targets;

table transmission_lines "inputs/transmission_lines.tab" IN: 
  TRANSMISSION_LINES <- [la_start, la_end], transmission_line_id, existing_transfer_capacity_mw, 
  transmission_length_km, transmission_efficiency, new_transmission_builds_allowed;
read table transmission_lines;

table study_hours "inputs/study_hours.tab" IN: 
  TIMEPOINTS <- [hour], period, date, hours_in_sample, month_of_year, hour_of_day;
read table study_hours;


table la_hourly_demand "inputs/la_hourly_demand.tab" IN: 
  [la_id, hour], la_demand_mwh, present_day_system_load;
read table la_hourly_demand;

table max_la_demand "inputs/max_la_demand.tab" IN: 
  [la_id, period], max_la_demand_mwh;
read table max_la_demand;

# PATY: THIS WAS ERASED: ep_carma_plant_id ~ carma_plant_id,
# PATY: Commented command just in the meantime JP fixes strings (spaces to _)
table existing_plants "inputs/existing_plants.tab" IN: 
  EXISTING_PLANTS <- [project_id, la_id, technology], 
  	ep_plant_name ~ plant_name, 
    ep_capacity_mw ~ capacity_mw, 
    ep_heat_rate ~ heat_rate, 
    ep_cogen_thermal_demand ~ cogen_thermal_demand_mmbtus_per_mwh,
    ep_vintage ~ start_year,  
    ep_overnight_cost ~ overnight_cost, 
    ep_connect_cost_per_mw ~ connect_cost_per_mw, 
    ep_fixed_o_m ~ fixed_o_m, 
    ep_variable_o_m ~ variable_o_m,
    ep_location_id;
 read table existing_plants;

table existing_plant_intermittent_capacity_factor "inputs/existing_plant_intermittent_capacity_factor.tab" IN: 
  EP_INTERMITTENT_HOURS <- [project_id, la_id, technology, hour], eip_capacity_factor ~ capacity_factor;
read table existing_plant_intermittent_capacity_factor;

# JP: Monthly limits split in existing and new keeping the same name for the existing to minimize switch.mod alterations.
table hydro_monthly_limits_ep "inputs/hydro_monthly_limits_ep.tab" IN: 
  PROJ_HYDRO_DATES <- [project_id, la_id, technology, date] average_hydro_output_mw ~ average_output_mw;
read table hydro_monthly_limits_ep;

table hydro_monthly_limits_new "inputs/hydro_monthly_limits_new.tab" IN: 
  PROJ_HYDRO_DATES_NEW <- [project_id, la_id, technology, date] average_hydro_output_mw_new_cf ~ average_output_cf;
read table hydro_monthly_limits_new;

# PATY: Commented command just in the meantime JP fixes strings (spaces to _)
table new_projects "inputs/new_projects.tab" IN: 
  PROJECTS <- [project_id, la_id, technology], location_id, ep_project_replacement_id,
    capacity_limit, capacity_limit_conversion, heat_rate, cogen_thermal_demand, connect_cost_per_mw, 
    overnight_cost, fixed_o_m, variable_o_m, overnight_cost_change;
read table new_projects;

table new_projects_intermittent_capacity_factor "inputs/new_projects_intermittent_capacity_factor.tab" IN: 
  PROJ_INTERMITTENT_HOURS <- [project_id, la_id, technology, hour], capacity_factor;
read table new_projects_intermittent_capacity_factor;

table generator_info "inputs/generator_info.tab" IN:  
	TECHNOLOGIES <- [technology], technology_id, min_build_year, fuel, construction_time_years,
 	year_1_cost_fraction, year_2_cost_fraction, year_3_cost_fraction, year_4_cost_fraction, year_5_cost_fraction, year_6_cost_fraction,
	max_age_years, forced_outage_rate, scheduled_outage_rate,
	can_build_new, ccs, intermittent, resource_limited, baseload, flexible_baseload, dispatchable, cogen, min_build_capacity, competes_for_space,
	storage, storage_efficiency, max_store_rate, max_spinning_reserve_fraction_of_capacity, heat_rate_penalty_spinning_reserve, minimum_loading, deep_cycling_penalty;
read table generator_info;

# PATY: added rps_fuel_category
table fuel_info "inputs/fuel_info.tab" IN:
	FUELS <- [fuel], rps_fuel_category, biofuel, carbon_content, carbon_sequestered;
read table fuel_info;

table fuel_prices "inputs/fuel_prices.tab" IN:
	[la_id, fuel, year], fuel_price;
read table fuel_prices;


###################################
# update some params that can't be easily dealt with elsewhere

# create cost fraction parameter for cost calculations and discounting for new and existing plants
# param cost_fraction { t in TECHNOLOGIES, yr in YEAR_OF_CONSTRUCTION };
for { t in TECHNOLOGIES } {
	let cost_fraction[t,0] := year_1_cost_fraction[t];
	let cost_fraction[t,1] := year_2_cost_fraction[t];
	let cost_fraction[t,2] := year_3_cost_fraction[t];
	let cost_fraction[t,3] := year_4_cost_fraction[t];
	let cost_fraction[t,4] := year_5_cost_fraction[t];
	let cost_fraction[t,5] := year_6_cost_fraction[t];
}
;

###################################
# Change the problem to remove policy constraints that are not in effect
problem Investment_Cost_Minimization;

# PATY'S EDIT: two lines below uncommented to make rps work.........
if (enable_rps = 0) then { drop Satisfy_RPS; } 
if (enable_carbon_cap = 0) then { drop Carbon_Cap; } 
## Simplify transmission & storage if RPS is not in effect
redeclare param rps_fuel_category {FUELS} symbolic;
if (enable_rps = 0) then {

# Paty: Uncommented line below
  let RPS_AREAS_AND_FUEL_CATEGORY := setof { (r, fc) in RPS_AREAS_AND_FUEL_CATEGORY } (r,'na'); 
  let {f in FUELS} rps_fuel_category[f] := 'na'; 
} 
redeclare param rps_fuel_category {FUELS} symbolic in RPS_FUEL_CATEGORY;


############################################################

# Make sure the model has valid data
check;

