include windsun.run;

param cost_solution_file symbolic;
param cost_problem_file symbolic;
param trans_problem_file symbolic;
param trans_solution_file symbolic;
param cost_solution_exists;
param trans_solution_exists;
param max_potential_solar_last_period;
let max_potential_solar_last_period :=
	( sum{ t in SOLAR_TECHNOLOGIES } max_potential_power[ t, last(PERIODS) ] )
	/ total_loads_by_period_weighted[ last( PERIODS ) ];

if ( enable_min_solar_production = 1 and max_potential_solar_last_period < min_solar_production ) then {
		printf "Warning! Policy goal of %2d\% solar in %.0d exceeds maximum potential of %2.2f\%, making the problem infeasible. Adjust the value of min_solar_production before proceeding.\n", 
			min_solar_production * 100, last(PERIODS), max_potential_solar_last_period * 100;
} else {


for {c in CARBON_COSTS} {
  let carbon_cost := c;
  let curtime := time();

  let cost_problem_file := "results/sol" & carbon_cost & "cost";
  let cost_solution_file := cost_problem_file & ".sol";
  let trans_problem_file := "results/sol" & carbon_cost & "trans";
  let trans_solution_file := trans_problem_file & ".sol";


  ###############################
  # Determine if which solutions already exists. 
  shell("if [ -f " & cost_solution_file & " ]; then echo 1 > sol_exists.txt; else echo 0 > sol_exists.txt; fi");
  read cost_solution_exists < "sol_exists.txt";
  close "sol_exists.txt";
  shell("rm sol_exists.txt");

  # Determine if the transmission solution already exists. 
  shell("if [ -f " & trans_solution_file & " ]; then echo 1 > sol_exists.txt; else echo 0 > sol_exists.txt; fi");
  read trans_solution_exists < "sol_exists.txt";
  close "sol_exists.txt";
  shell("rm sol_exists.txt");


  ###############################
  # Cost optimization

  if ( cost_solution_exists )
  then {
    printf "\nLoading Cost solution from disk for a carbon cost of %d.\n", carbon_cost;
    solution (cost_solution_file);
  } else {
    printf "\nCost solution not found on disk for a carbon cost of %d; solving optimization problem.\n", carbon_cost;
    write ("b" & cost_problem_file);
    solve;
    printf "%d seconds to optimize for cost.", time() - curtime;
    # Remove the transmission problem if it exists; It will need to be re-run from the new cost solution
    if ( trans_solution_exists )
    then {
      shell ("rm trans_problem_file trans_solution_file");
      let trans_solution_exists := 0;
    }    
  }

  # show some info about this run
#  include basicstats.run;



  ###############################
  # Transmission optimization
  # All decision variables except DispatchTransFromXToY are fixed for the transmission usage objective function

  fix InstallGen;
  fix BuildGenOrNot;
  fix DispatchGen;
  fix OperateEPDuringPeriod;
  fix DispatchEP;
  fix InstallTrans;
  fix DispatchTransFromXToY_Reserve;
  fix InstallLocalTD;
  fix StorePumpedHydro;
  fix DispatchHydro;
  fix StorePumpedHydro_Reserve;
  fix DispatchHydro_Reserve;
  objective Transmission_Usage;
  option presolve_eps 1e-10;

  if ( trans_solution_exists )
  then {
    printf "\nLoading Transmission solution from disk for a carbon cost of %d.\n", carbon_cost;
    solution (trans_solution_file);
    # show some info about this run
    include basicstats.run;

  } else {

    printf "\nTransmission solution not found on disk for a carbon cost of %d; solving optimization problem.\n", carbon_cost;
    let curtime := time();
    
    write ("b" & trans_problem_file);
    solve;

    printf "\n%d seconds to optimize for transmission.\n", time() - curtime;

    # show some info about this run
    include basicstats.run;

  }

  # export the results to csv files and the like
  include record_results.run;

  unfix InstallGen;
  unfix BuildGenOrNot;
  unfix DispatchGen;
  unfix OperateEPDuringPeriod;
  unfix DispatchEP;
  unfix InstallTrans;
  unfix DispatchTransFromXToY_Reserve;
  unfix InstallLocalTD;
  unfix StorePumpedHydro;
  unfix DispatchHydro;
  unfix StorePumpedHydro_Reserve;
  unfix DispatchHydro_Reserve;
  objective Power_Cost;


  # restore the cost solution
  solution (cost_solution_file);

}

}