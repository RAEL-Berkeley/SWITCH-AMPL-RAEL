include windsun.run;
include min_solar_production_check.run;

param cost_problem_file symbolic;
param cost_solution_file symbolic;
param trans_problem_file symbolic;
param trans_solution_file symbolic;
param num_result_files;


problem Cost_Minimization;
# Add policy constraints as needed.
if (enable_rps = 1                 ) then { restore Satisfy_RPS; };
if (enable_min_solar_production = 1) then { restore Min_Gen_Fraction_From_Solar; };

for {c in CARBON_COSTS} {
  let carbon_cost := c;

  let cost_problem_file := results_path & "sol" & carbon_cost & "cost";
  let cost_solution_file := cost_problem_file & ".sol";
  let trans_problem_file := results_path & "sol" & carbon_cost & "trans";
  let trans_solution_file := trans_problem_file & ".sol";


  ###############################
  # Cost optimization
  # Determine if a cost solution already exists. 
  shell("if [ -f " & cost_solution_file & " ]; then echo 1 > sol_exists.txt; else echo 0 > sol_exists.txt; fi");
  read file_exists < "sol_exists.txt";
  close "sol_exists.txt";
  shell("rm sol_exists.txt");
  if ( file_exists )
  then {
    printf "\nLoading Cost solution from disk for a carbon cost of %d.\n", carbon_cost;
    let curtime := time();
    solution (cost_solution_file);
    printf "%d seconds to create a problem instance and load a solution from disk.\n", (time() - curtime);
  } else {
    printf "\nCost solution not found on disk for a carbon cost of %d; solving optimization problem.\n", carbon_cost;
    let curtime := time();
    write ("b" & cost_problem_file);
    let cost_compile_time := time() - curtime;
    printf "%d seconds to compile and write the problem file.\n", cost_compile_time;
    let curtime := time();
    solve;
    let cost_sol_time := time() - curtime;
    printf "%d seconds to optimize for cost.\n", cost_sol_time;
    # Remove the transmission problem if it exists; It will need to be re-run from the new cost solution
	shell("if [ -f " & trans_solution_file & " ]; then echo 1 > sol_exists.txt; else echo 0 > sol_exists.txt; fi");
	read file_exists < "sol_exists.txt";
	close "sol_exists.txt";
	shell("rm sol_exists.txt");
    if ( file_exists )
    then {
      shell ("rm trans_problem_file trans_solution_file");
      let file_exists := 0;
    }    
  }


  ###############################
  # Transmission optimization
  # All decision variables except DispatchTransFromXToY are fixed for the transmission usage objective function

  problem Transmission_Minimization;

  # Determine if the transmission solution already exists. 
  shell("if [ -f " & trans_solution_file & " ]; then echo 1 > sol_exists.txt; else echo 0 > sol_exists.txt; fi");
  read file_exists < "sol_exists.txt";
  close "sol_exists.txt";
  shell("rm sol_exists.txt");

  if ( file_exists )
  then {
    printf "\nLoading Transmission solution from disk for a carbon cost of %d.\n", carbon_cost;
    let curtime := time();
    solution (trans_solution_file);
    printf "%d seconds to create a problem instance and load a solution from disk.\n", (time() - curtime);

  } else {

    printf "\nTransmission solution not found on disk for a carbon cost of %d; solving optimization problem.\n", carbon_cost;
    let curtime := time();
    write ("b" & trans_problem_file);
    printf "\n%d seconds to compile and write the problem file.\n", (time() - curtime);
    solve;
    let trans_sol_time := time() - curtime;
    printf "\n%d seconds to optimize for transmission.\n", trans_sol_time;

  }

  include update_reporting_vars.run;
  
  # show some info about this run
  include basicstats.run;

  # export the results to csv files and the like if they haven't already been exported
  include record_results.run;

  
  # restore the cost solution
  problem Cost_Minimization;
  # Add policy constraints as needed.
  if (enable_rps = 1                 ) then { restore Satisfy_RPS; };
  if (enable_min_solar_production = 1) then { restore Min_Gen_Fraction_From_Solar; };
  let curtime := time();
  solution (cost_solution_file);
  printf "%d seconds to reload the cost solution from disk.\n", (time() - curtime);

}
