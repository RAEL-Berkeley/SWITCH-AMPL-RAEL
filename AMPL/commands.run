include load.run; 
include lagrangian_problem.run;

#let target_period := 2015;
#option auxfiles cfrsu; write ("m" & problem_basename); 
#solve;
# display {i in 1.._ncons: _con[i].iis <> "non"} (_conname[i], _con[i].iis);

# Iterate a few times...
for {i in 1..iteration_limit} {
#for {i in 1..2} {
  let iteration := i;

  # Solve the subproblems
  problem Lagrang_Subprob;
  include tweak_problem.run;
  for {tp in PERIODS} {
    let target_period := tp;
    display iteration, target_period;
    if ( file_exists(subsolution_path) = 0 ) then {
      write ("b" & subproblem_basename);
      solve;
    } else {
      solution(subsolution_path);
    }
    include export_subproblem_decisions.run;
  }
  # Read in the subproblem outcomes and average values from the last iteration
  include import_subproblem_decisions.run;

  # Calculate the gap from the last iteration
  # InstallGen_LGN_GAP, InstallStorageEnergyCapacity_LGN_GAP, BuildGenOrNot_LGN_GAP, 
  # InstallTrans_LGN_GAP, InstallLocalTD_LGN_GAP, OperateEPDuringPeriod_LGN_GAP
  # Calculate the penalties
  # First the "norm": The sum of the squares of all the gaps
  # norm
  # Calculate the lower bound of the extensive form of the problem, which is the sum of the objectives from all of the subproblems
  # ext_prob_objective_value[iteration]
  # Calculate an upper bound of the extensive form of the problem.. Take the max of each investment decision & run dispatch.
  include lagrang_upper_bound.run;

  # Determine how long it has been since the lower bound has changed.. 
  # If it has been more than iterations_since_improvement_limit, then 
  # reduce the scalar step multiplier by a factor of 2. 
  let ext_prob_objective_value[iteration] :=
    sum{tp in PERIODS} sub_prob_objective_values[iteration, tp];
  if (iteration > 1) then {
    if (ext_prob_objective_value[iteration] > ext_prob_objective_value[iteration-1] + 0.000001) then {
      let iterations_since_improvement := 0;
    } else {
      let iterations_since_improvement := iterations_since_improvement + 1;
    }
  }
  if ( iterations_since_improvement >= iterations_since_improvement_limit ) then {
    let scale := scale/2;
    let iterations_since_improvement := 0;
  }

  # Update the deviation penalties
  let { (pid, a, t, p, tp) in PROJECT_VINTAGES_LGN }
    InstallGen_DEV_PNTLY[pid, a, t, p, tp] := 
      InstallGen_DEV_PNTLY[pid, a, t, p, tp]
      + step_size * InstallGen_LGN_GAP[pid, a, t, p, tp];
  let { (pid, a, t, p, tp) in PROJECT_VINTAGES_LGN: storage[t] }
    InstallStorageEnergyCapacity_DEV_PNTLY[pid, a, t, p, tp] := 
      InstallStorageEnergyCapacity_DEV_PNTLY[pid, a, t, p, tp]
      + step_size * InstallStorageEnergyCapacity_LGN_GAP[pid, a, t, p, tp];
  let { (pid, a, t, p, tp) in PROJECT_VINTAGES_LGN: min_build_capacity[t] > 0 }
    BuildGenOrNot_DEV_PNTLY[pid, a, t, p, tp] :=
      BuildGenOrNot_DEV_PNTLY[pid, a, t, p, tp]
      + step_size * BuildGenOrNot_LGN_GAP[pid, a, t, p, tp];
  let { (a1, a2, p, tp) in TRANSMISSION_LINE_NEW_PERIODS_LGN }
    InstallTrans_DEV_PNTLY[a1, a2, p, tp] := 
      InstallTrans_DEV_PNTLY[a1, a2, p, tp]
      + step_size * InstallTrans_LGN_GAP[a1, a2, p, tp];
  let { (a, p, tp) in LOCAL_TD_NEW_PERIODS_LGN }
    InstallLocalTD_DEV_PNTLY[a, p, tp] :=
      InstallLocalTD_DEV_PNTLY[a, p, tp]
      + step_size * InstallLocalTD_LGN_GAP[a, p, tp];
  let { (pid, a, t, p, tp) in EP_PERIODS_LGN: not intermittent[t] and not hydro[t] }
    OperateEPDuringPeriod_DEV_PNTLY[pid, a, t, p, tp] := 
      OperateEPDuringPeriod_DEV_PNTLY[pid, a, t, p, tp]
      + step_size * OperateEPDuringPeriod_LGN_GAP[pid, a, t, p, tp];

};
