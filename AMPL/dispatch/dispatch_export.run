include basicstats.run;

# Store additional peakers needed
if( file_exists( peaker_solution_file ) == 1 ) then {
  let outfile := results_path & sprintf( "dispatch_extra_peakers_%d.txt", carbon_cost );
  printf "scenario_id	carbon_cost	period	pid	load_area_id	load_area	test_set_id	technology_id	technology	new	baseload	cogen	storage	fuel	additional_capacity updated_capacity	capital_cost	fixed_o_m_cost\n"
    > (outfile);
  printf {(pid, a, t, p) in PROJECT_VINTAGES_ALL: (t='Gas_Combustion_Turbine' or storage[t]) and (InstallGen[pid, a, t, p] - InstallGen_Init[pid, a, t, p])  > 0.001}
    "%s	%d	%d	%d	%d	%s	%d	%d	%s	%s	%d	%d	%d	%s	%.2f	%.2f	%.2f	%.2f\n",
    scenario_id, carbon_cost, p, pid, load_area_id[a], a, test_set_id, technology_id[t], t, location_id[pid, a, t], 1, baseload[t], cogen[t], fuel[t],
    (InstallGen[pid, a, t, p] - InstallGen_Init[pid, a, t, p]),
    InstallGen[pid, a, t, p],
    Capital_Payments_by_Plant_and_Period[pid, a, t, p],
    Fixed_OM_by_Plant_and_Period[pid, a, t, p]
    >> (outfile);
  close(outfile);
}

#########################
# Store hourly dispatch summary for each load area and technology
let outfile := results_path & sprintf( "dispatch_sums_%d.txt", carbon_cost );
printf "scenario_id	carbon_cost	period	load_area_id	load_area	balancing_area	date	hour	test_set_id	technology_id	technology	new	baseload	cogen	storage	fuel	fuel_category	hours_in_sample	power	co2_tons	heat_rate	fuel_cost	carbon_cost_sum	variable_o_m	spinning_reserve	quickstart_capacity	total_operating_reserve	spinning_co2_tons	spinning_fuel_cost	spinning_carbon_cost_incurred	deep_cycling_amount	deep_cycling_fuel_cost	deep_cycling_carbon_cost	deep_cycling_co2_tons	mw_started_up	startup_fuel_cost	startup_nonfuel_cost	startup_carbon_cost	startup_co2_tons\n"
  > (outfile);


# New Plants
printf { t in TECHNOLOGIES, a in LOAD_AREAS, h in TIMEPOINTS: can_build_new[t] and t <> 'Battery_Storage' and sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} (Power_Produced[pid, a, t, p, h] + Total_Operating_Reserve_Provided[pid, a, t, p, h]) > 0.0001 } 
  "%s	%d	%d	%d	%s	%s	%d	%d	%s	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], load_area_id[a], a, balancing_area[a], 
  date[h], h, test_set_id,
  technology_id[t], t, 1, baseload[t], 0, 0, fuel[t], rps_fuel_category[fuel[t]], 
  dispatch_hours_in_sample[period[h]],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Power_Produced[pid, a, t, p, h], 
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Carbon_Emissions[pid, a, t, p, h],
  # Avg heat rate for this technology, weighted by capacity.
  if( (sum{(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Installed_To_Date[pid, a, t, period[h]]) <= 0 ) 
    then 0 
    else (sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} heat_rate[pid, a, t] * Installed_To_Date[pid, a, t, period[h]] ) / (sum{(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Installed_To_Date[pid, a, t, period[h]]), 
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Variable_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Spinning_Reserve_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Quickstart_Capacity_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Total_Operating_Reserve_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Thermal_Spinning_Reserve_Carbon_Emissions[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Thermal_Spinning_Reserve_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Thermal_Spinning_Reserve_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Amount_Deep_Cycled[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Deep_Cycling_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Deep_Cycling_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Deep_Cycling_Carbon_Emissions[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Startup_MW[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Startup_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Startup_NonFuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Startup_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in PROJECT_VINTAGE_HOURS} Startup_Carbon_Emissions[pid, a, t, p, h]
  >> (outfile);

# Existing Plants
printf { t in TECHNOLOGIES, a in LOAD_AREAS, h in TIMEPOINTS: not can_build_new[t] and sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS } (ProducePowerEP[pid, a, t, p, h] + Total_Operating_Reserve_Provided[pid, a, t, p, h]) >= 0.001} 
  "%s	%d	%d	%d	%s	%s	%d	%d	%s	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], load_area_id[a], a, balancing_area[a], 
  date[h], h, test_set_id,
  technology_id[t], t, 0, baseload[t], cogen[t], 0, fuel[t], rps_fuel_category[fuel[t]], 
  dispatch_hours_in_sample[period[h]],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} ProducePowerEP[pid, a, t, p, h], 
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} EP_Carbon_Emissions[pid, a, t, p, h],
  # Avg heat rate for this technology, weighted by capacity.
  if( (sum{(pid, a, t, p, h) in EP_AVAILABLE_HOURS} ep_capacity_mw[pid, a, t]) <= 0 ) 
    then 0 
    else (sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} ep_heat_rate[pid, a, t] * ep_capacity_mw[pid, a, t] ) / (sum{(pid, a, t, p, h) in EP_AVAILABLE_HOURS} ep_capacity_mw[pid, a, t]), 
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} EP_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} EP_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} EP_Variable_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Spinning_Reserve_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Quickstart_Capacity_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Total_Operating_Reserve_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Thermal_Spinning_Reserve_Carbon_Emissions[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Thermal_Spinning_Reserve_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Thermal_Spinning_Reserve_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Amount_Deep_Cycled[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Deep_Cycling_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Deep_Cycling_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Deep_Cycling_Carbon_Emissions[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Startup_MW[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Startup_Fuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Startup_NonFuel_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Startup_Carbon_Cost_Incurred_Hourly[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in EP_AVAILABLE_HOURS} Startup_Carbon_Emissions[pid, a, t, p, h]
  >> (outfile);

# Store all STORAGE DISPATCH decisions
printf {  t in TECHNOLOGIES, a in LOAD_AREAS, h in TIMEPOINTS: storage[t]
	and ( 
      (sum {(pid, a, t, p, h) in AVAILABLE_HOURS} abs(Storage_Net_Power[pid, a, t, p, h]) ) > 0.01 or
      (sum {(pid, a, t, p, h) in AVAILABLE_HOURS} abs(Storage_Operating_Reserve_Provided[pid, a, t, p, h]) ) > 0.01
    ) }
  "%s	%d	%d	%d	%s	%s	%d	%d	%s	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, period[h], load_area_id[a], a, balancing_area[a], 
  date[h], h, test_set_id,
  technology_id[t], t, can_build_new[t], 0, 0, 1, 'Storage', 'Storage', dispatch_hours_in_sample[period[h]],
  sum {(pid, a, t, p, h) in AVAILABLE_HOURS} Storage_Net_Power[pid, a, t, p, h],
  0, 0, 0, 0,
  if dispatchable[t] then 0 else (sum {(pid, a, t, p, h) in AVAILABLE_HOURS} Storage_Variable_Cost_Incurred_Hourly[pid, a, t, p, h]),
  sum {(pid, a, t, p, h) in AVAILABLE_HOURS} Storage_Spinning_Reserve_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in AVAILABLE_HOURS} Storage_Quickstart_Capacity_Provided[pid, a, t, p, h],
  sum {(pid, a, t, p, h) in AVAILABLE_HOURS} Storage_Operating_Reserve_Provided[pid, a, t, p, h],
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
  >> (outfile);

close(outfile);
