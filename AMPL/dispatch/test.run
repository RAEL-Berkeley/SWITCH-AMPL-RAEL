include windsun.run;

param do_not_solve = 1;

set PROJECT_VINTAGES_ALL dimen 4;
set PROJ_MIN_BUILD_VINTAGES_ALL dimen 4;
set EP_PERIODS_ALL dimen 4;
set TRANSMISSION_LINE_VINTAGES_ALL dimen 3;
set LocalTD_VINTAGES_ALL dimen 2;
param InstallGen_Init {PROJECT_VINTAGES_ALL};
param OperateEPDuringPeriod_Init {EP_PERIODS_ALL} >= 0, <= 1, integer;
param InstallTrans_Init {TRANSMISSION_LINE_VINTAGES_ALL} >= 0;
param cost_compile_time default -1; 
param cost_sol_time default -1;


subject to Increase_Gen_Only {(pid, a, t, p) in PROJECT_VINTAGES_ALL}:
	InstallGen_Init[pid, a, t, p] <= InstallGen[pid, a, t, p];

problem Dispatch_Only: 
  # Objective function 
	Power_Cost, 

  # Satisfy Load
  Satisfy_Load,
  # Load Area Level Dispatch Variables
  ConsumeNonDistributedPower, ConsumeDistributedPower, RedirectDistributedPower,
	Conservation_Of_Energy_NonDistributed, Conservation_Of_Energy_Distributed,
	
	# Dispatch can install more peakers or local T&D only if the investments generate infeasibilities.
	Increase_Gen_Only,  

  # Dispatch Decisions
	DispatchGen, OperateEPDuringPeriod, ProducePowerEP, ConsumeBioSolid, DispatchTransFromXToY, StoreEnergy, ReleaseEnergy,
	Dispatch_NonPumped_Hydro, Dispatch_Pumped_Hydro_Watershed_Electrons, Dispatch_Pumped_Hydro_Storage, Store_Pumped_Hydro,
  # Dispatch Constraints
	Power_From_Dispatchable_Plants, 
	EP_Operational_Continuity, EP_Power_From_Dispatchable_Plants, EP_Power_From_Intermittent_Plants, EP_Power_From_Baseload_Plants,
	Maximum_DispatchTransFromXToY, Minimum_LocalTD, 
	Maximum_Dispatch_NonPumped_Hydro, Average_NonPumped_Hydro_Output,        Minimum_Dispatch_NonPumped_Hydro, 
	Maximum_Dispatch_Pumped_Hydro,    Average_Pumped_Hydro_Watershed_Output,
	Maximum_Store_Pumped_Hydro, Conservation_Of_Stored_Pumped_Hydro_Electrons,
	CAES_Combined_Dispatch, Maximum_Store_Rate, Maximum_Release_Storage_Rate, Storage_Projects_Energy_Balance	
;


table TableInstallGen IN "inputs/InstallGen.tab": 
	PROJECT_VINTAGES_ALL <- [ pid, a, t, p ], InstallGen_Init ~ InstallGen;
table TableOperateEPDuringPeriod IN "inputs/OperateEPDuringPeriod.tab": 
	EP_PERIODS_ALL <- [pid, a, t, p], OperateEPDuringPeriod_Init ~ OperateEPDuringPeriod;
table TableInstallTrans IN "inputs/InstallTrans.tab":
	TRANSMISSION_LINE_VINTAGES_ALL <- [a1, a2, p], InstallTrans_Init ~ InstallTrans;

param cost_problem_file symbolic;
param cost_solution_file symbolic;
param infeasible_path symbolic;
param week_num;

for {c in CARBON_COSTS} {
  let carbon_cost := c;
  let cost_problem_file := results_path & "sol" & carbon_cost & "dispatch";
  let cost_solution_file := cost_problem_file & ".sol";
  
  ###############################
  # Load the investment decisions
  let curtime := time();
  shell( "for f in InstallGen OperateEPDuringPeriod InstallTrans; do p=inputs/$f.tab; if [ -L $p ]; then rm $p; fi; done" );
  shell( "for f in InstallGen OperateEPDuringPeriod InstallTrans; do ln -s ${f}" & carbon_cost & ".tab inputs/$f.tab; done" );
  read table TableInstallGen;
  read table TableOperateEPDuringPeriod;
  read table TableInstallTrans;
  close;
  shell( "for f in InstallGen OperateEPDuringPeriod InstallTrans; do p=inputs/$f.tab; if [ -L $p ]; then rm $p; fi; done" );
  for {(pid, a, t, p) in PROJECT_VINTAGES} {
    let InstallGen[pid, a, t, p] := max(InstallGen_Init[pid, a, t, p], 0);
  }
  for {(a1, a2) in TRANSMISSION_LINES_NEW_BUILDS_ALLOWED, p in PERIODS} {
    let InstallTrans[a1, a2, p] := InstallTrans_Init[a1, a2, p];
  }
  for {(pid, a, t, p) in EP_PERIODS_ALL} {
    let OperateEPDuringPeriod[pid, a, t, p] := OperateEPDuringPeriod_Init[pid, a, t, p];
  }
  printf "%d seconds to load investment decisions from disk for carbon cost %d.\n", (time() - curtime), carbon_cost;
  
  ###############################
  # Cost optimization
  # Determine if a cost solution already exists. 
  if ( file_exists(cost_solution_file) == 1 )
  then {
    printf "Dispatch solution found for a carbon cost of %d.\n", carbon_cost;
    printf "Loading prior solution from %s.\n", cost_solution_file;
    solution( cost_solution_file );
  } else {
    printf "Dispatch solution not found on disk for a carbon cost of %d; solving optimization problem.\n", carbon_cost;
    if( do_not_solve == 1 and file_exists( ( cost_problem_file & ".nl" ) ) == 0 ) 
    then {
      let curtime := time();
      write ("b" & cost_problem_file);
      let cost_compile_time := time() - curtime;
      printf "%d seconds to compile and write the problem file.\n", cost_compile_time;
    }
    if( do_not_solve == 0 ) then {
      let curtime := time();
      solve;
      let cost_sol_time := time() - curtime;
      printf "%d seconds to optimize dispatch for cost.\n", cost_sol_time;
    }
  }

  if( solve_result = 'infeasible' ) then {
    printf "Infeasible problem. Allowing installation of more peakers and local T&D.\n";
# Code to print infeasibilities. AMPL is a jerk and complains about the .iis suffix not being available if you have this code in a loop. It doesn't even try to enter the loop and load the solution file before it craps out.
#    let infeasible_path := results_path & "infeasible_vars_" & carbon_cost & "_dispatch.csv";
#    csvdisplay {i in 1.._nvars: _var[i].iis <> "non" }: "%s,%s\n", _varname[i], _var[i].iis > infeasible_path;
#    let infeasible_path := results_path & "infeasible_constraints_" & carbon_cost & "_dispatch.csv";
#    csvdisplay {i in 1.._ncons: _con[i].iis <> "non"}: _conname[i], _con.iis[i] > infeasible_path;
#    close;
    for {(pid, a, t, p) in PROJECT_VINTAGES: t='Gas_Combustion_Turbine'} {
      unfix InstallGen[pid, a, t, p];
    }
    let curtime := time();
    write ("b" & cost_problem_file);
    let cost_compile_time := time() - curtime;
    printf "%d seconds to compile and write the problem file.\n", cost_compile_time;
    let curtime := time();
    solve;
    let cost_sol_time := time() - curtime;
    printf "%d seconds to optimize dispatch for cost.\n", cost_sol_time;
    printf {p in PERIODS} "%d: %.3f additional peakers installed.\n", p, (sum{(pid, a, t, p) in PROJECT_VINTAGES_ALL: t='Gas_Combustion_Turbine'} (InstallGen[pid, a, t, p] - InstallGen_Init[pid, a, t, p]));
    fix InstallGen;
  }

  if( solve_result = 'infeasible' ) then {
    printf "Problem is still infeasible. You need to check it manually.\n";
  } else {
    let outfile := results_path & sprintf( "dispatch_sums_%d.txt", carbon_cost );
    if( file_exists(outfile) == 0 and file_exists(cost_solution_file) == 1) then {
      printf "Preparing to write summary dispatch file %s.\n", outfile;
      if( solve_result != 'solved' ) then {
        printf "Loading prior solution from %s.\n", cost_solution_file;
        solution( cost_solution_file );
      }
      let curtime := time();
#      include record_dispatch_sums.run;
      printf "%d seconds to record dispatch sums.\n", time() - curtime;
    }
  }

}


