let curtime := time();


if ( file_exists(solution_times_path) == 0 )
then {
  printf "scenario_id	carbon_cost	process_type time_seconds\n"
  > (solution_times_path);
  close (solution_times_path);
}
# Store solution times
if ( cost_sol_time >= 0 ) then {
	printf "%d	%d	%s	%d\n", scenario_id, carbon_cost, "Cost_Compilation", dispatch_cost_compile_time  >> (solution_times_path);
	printf "%d	%d	%s	%d\n", scenario_id, carbon_cost, "Cost_Optimization", dispatch_cost_sol_time  >> (solution_times_path);
	close (solution_times_path);
}

read week_num < "week_num.txt";

param hours_per_period {p in PERIODS} = sum {h in TIMEPOINTS: period[h] = p } hours_in_sample[h];
param dispatch_hours_in_sample {p in PERIODS} = hours_in_sample[h] / card( {h in TIMEPOINTS: period[h] = p } );

for { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: t <> 'Battery_Storage' } {
	let Power_Produced[pid, a, t, p, h] :=
		(	if	 	dispatchable[t] then DispatchGen[pid, a, t, p, h]
			else if	intermittent[t] then InstallGenTotal[pid, a, t, p] * cap_factor[pid, a, t, h] * gen_availability[t]
			else if	baseload[t] 	then InstallGenTotal[pid, a, t, p] * gen_availability[t] );
}

#########################
# Store the sums of the dispatches for each plant
let outfile := results_path & sprintf( "dispatch_sums_%d.txt", carbon_cost );
printf "scenario_id	carbon_cost	period	project_id	load_area_id	load_area	week_num	technology_id	technology	new	baseload	cogen	storage	fuel	fuel_category	hours_in_sample	power	co2_tons	heat_rate	fuel_cost	carbon_cost_sum	variable_o_m\n"
  > (outfile);

# New Plants
printf { (pid, a, t, p) in PROJECT_VINTAGES: sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] >= 0.005 } 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 1, baseload[t], 0, 0, fuel[t], rps_fuel_category_tech[t], 
  dispatch_hours_in_sample[p],
  # Power output
  (sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] * hours_in_sample[h] ) / hours_per_period[p], 
  # Carbon emmissions.
  (sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] * heat_rate[t] * carbon_content[fuel[t]] * hours_in_sample[h] ) / hours_per_period[p],
  heat_rate[t], 
  # Fuel costs incurred hourly
  (sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] * heat_rate[t] * fuel_cost_hourly[a, fuel[t], h] * hours_in_sample[h] ) / hours_per_period[p],
  # Carbon_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] * carbon_content[fuel[t]] * carbon_cost * hours_in_sample[h] ) / hours_per_period[p],
  # Variable_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p} Power_Produced[pid, a, t, p, h] * variable_o_m[pid, a, t] * hours_in_sample[h] ) / hours_per_period[p]
  >> (outfile);


# Existing Plants
printf {(pid, a, t, p) in EP_PERIODS: (sum {h in TIMEPOINTS: period[h] = p } ProducePowerEP[pid, a, t, p]) >= 0.005} 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, ep_project_id[pid, a, t], load_area_id[a], a, week_num,
  technology_id[t], t, 0, baseload[t], cogen[t], 0, fuel[t], rps_fuel_category_tech[t], 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} ProducePowerEP[pid, a, t, p, h] * hours_in_sample[h] ) / hours_per_period[p], 
  # EP_Carbon_Emissions
  (sum {h in TIMEPOINTS: period[h] = p} ProducePowerEP[pid, a, t, p, h] * ep_heat_rate[pid, a, t] * carbon_content[fuel[t]] * hours_in_sample[h] ) / hours_per_period[p],
  ep_heat_rate[pid, a, t], 
  # EP_Fuel_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p} ProducePowerEP[pid, a, t, p, h] * ep_heat_rate[pid, a, t] * fuel_cost_hourly[a, fuel[t], h] * hours_in_sample[h] ) / hours_per_period[p],
  # EP_Carbon_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p} ProducePowerEP[pid, a, t, p, h] * ep_heat_rate[pid, a, t] * carbon_content[fuel[t]] * carbon_cost * hours_in_sample[h] ) / hours_per_period[p],
  # EP_Variable_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p} ProducePowerEP[pid, a, t, p, h] * ep_variable_o_m[pid, a, t] * hours_in_sample[h] ) / hours_per_period[p]
  >> (outfile);

# Dispatch of non-pumped hydro. 
printf {(pid, a, t, p) in NONPUMPED_HYDRO_PERIODS} 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 0, 0, 0, 0, fuel[t], rps_fuel_category_tech[t], 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p } Dispatch_NonPumped_Hydro[pid, a, t, p, h] * hours_in_sample[h]) / hours_per_period[p],
  0, 0, 0, 0, 
  # NonPumped_Hydro_Variable_Cost_Incurred_Hourly
  (sum {h in TIMEPOINTS: period[h] = p } Dispatch_NonPumped_Hydro[pid, a, t, p, h] * nonpumped_hydro_variable_o_m * economic_multiplier[a] * hours_in_sample[h] ) / hours_per_period[p]
  >> (outfile);

# Dispatch of pumped hydro watershed electrons. 
printf {(pid, a, t, p) in PUMPED_HYDRO_PERIODS} 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 0, 0, 0, 0, fuel[t], rps_fuel_category_tech[t], 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} Dispatch_Pumped_Hydro_Watershed_Electrons[pid, a, t, p, h] / hours_per_period[p],
  0, 0, 0, 0, 
  0 # Pumped Hydro has 0 Variable O&M costs, as they are wrapped up in Fixed O&M costs
  >> (outfile);


# Store all STORAGE DISPATCH decisions

# Storage of pumped hydro. Don't have to pay variable O&M for storing at the moment.
printf {(pid, a, t, p) in PUMPED_HYDRO_PERIODS, fc in RPS_FUEL_CATEGORY: (sum {h in TIMEPOINTS: period[h] = p} Store_Pumped_Hydro[pid, a, t, p, h, fc]) >= 0.005 } 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 0, 0, 0, 1, 'Storage', fc, 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} -1 * Store_Pumped_Hydro[pid, a, t, p, h, fc] * hours_in_sample[h]) / hours_per_period[p],
  0, 0, 0, 0, 0
  >> (outfile);

# Dispatch of stored pumped hydro.
printf {(a, pid) in PROJ_PUMPED_HYDRO, p in PERIODS, fc in RPS_FUEL_CATEGORY: (sum {h in TIMEPOINTS: period[h] = p } Dispatch_Pumped_Hydro_Storage[pid, a, t, p, h, fc]) >= 0.005} 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 0, 0, 0, 1, 'Storage', fc, 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} Dispatch_Pumped_Hydro_Storage[pid, a, t, p, h, fc] * hours_in_sample[h]) / hours_per_period[p],
  0, 0, 0, 0, 0
  >> (outfile);
  
# New storage projects while storing energy. Don't have to pay variable O&M for storing at the moment.
printf {(pid, a, t) in PROJ_STORAGE, p in PERIODS, fc in RPS_FUEL_CATEGORY: (sum {h in TIMEPOINTS: period[h] = p } StoreEnergy[pid, a, t, h, fc]) >= 0.005 } 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 1, 0, 0, 1, 'Storage', fc, 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} -1 * StoreEnergy[pid, a, t, h, fc] * hours_in_sample[h]) / hours_per_period[p],
  0, 0, 0, 0, 0
  >> (outfile);

# New storage projects while releasing energy.
printf {(pid, a, t) in PROJ_STORAGE, p in PERIODS, fc in RPS_FUEL_CATEGORY: (sum {h in TIMEPOINTS: period[h] = p } ReleaseEnergy[pid, a, t, h, fc]) >= 0.005 } 
  "%s	%d	%d	%d	%d	%s	%d	%d	%s	%d	%d	%d	%d	%s	%s	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f	%.2f\n",
  scenario_id, carbon_cost, p, pid, load_area_id[a], a, week_num,
  technology_id[t], t, 1, 0, 0, 1, 'Storage', fc, 
  dispatch_hours_in_sample[p],
  (sum {h in TIMEPOINTS: period[h] = p} ReleaseEnergy[pid, a, t, h, fc] * hours_in_sample[h]) / hours_per_period[p],
  0, 0, 0, 0,
  (sum {h in TIMEPOINTS: period[h] = p} ReleaseEnergy[pid, a, t, h, fc] * variable_o_m[pid, a, t] * hours_in_sample[h]) / hours_per_period[p]
  >> (outfile);

close (outfile);
