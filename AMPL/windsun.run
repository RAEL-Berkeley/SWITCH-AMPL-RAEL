# note: this script should be called from a directory
# holding all the tab files.

reset;
if match($version, 'Darwin') > 0 then {
  #option solver cbc;
  # note: you also need to use codeweavers to open the ampl1 bottle and then call wine --cx-app=ilmd.exe
  option solver cplexamp;
#  Old setting for single-threaded execution
#  option cplex_options 'primalopt lpdisplay=1 mipdisplay=1';
# New settings for multi-threaded execution
#  option cplex_options 'lpdisplay=1 threads=8 mipdisplay=1';
  option cplex_options 'lpdisplay=1 iisfind=1 mipdisplay=1';
} else {
  option solver cplexamp;
#  Old setting for single-threaded execution
#  option cplex_options 'lpdisplay=1 threads=6 mipdisplay=1';
# New settings for multi-threaded execution
  option cplex_options 'lpdisplay=1 threads=8 mipdisplay=1';
}
option presolve 0;

model windsun.mod;

data windsun.dat;

table study_hours IN: TIMEPOINTS <- [hour], period, date, hours_in_sample, month_of_year, hour_of_day;
read table study_hours;

table load_areas IN: LOAD_AREAS <- [load_area], economic_multiplier, rps_compliance_year, rps_compliance_percentage;
read table load_areas;

table transmission_lines IN: 
  TRANSMISSION_LINES <- [load_area_start, load_area_end], existing_transfer_capacity_mw, transmission_line_id, 
  transmission_length_km, transmission_efficiency;
read table transmission_lines;

table system_load IN: [load_area, hour], system_load;
read table system_load;

table existing_plants IN: 
  EXISTING_PLANTS <- [load_area, plant_code], 
    ep_size_mw ~ size_mw, ep_technology ~ technology, ep_fuel ~ fuel, ep_heat_rate ~ heat_rate, 
    ep_vintage ~ start_year, ep_max_age_years ~ max_age, 
    ep_overnight_cost ~ overnight_cost, ep_fixed_o_m ~ fixed_o_m, ep_variable_o_m ~ variable_o_m,
    ep_forced_outage_rate ~ forced_outage_rate, ep_scheduled_outage_rate ~ scheduled_outage_rate, 
    ep_baseload ~ baseload, ep_cogen ~ cogen, ep_intermittent ~ intermittent;
read table existing_plants;

table existing_intermittent_plant_cap_factor IN: 
  EP_INTERMITTENT_HOURS <- [load_area, plant_code, hour], eip_cap_factor ~ cap_factor;
read table existing_intermittent_plant_cap_factor;

table hydro IN: 
  PROJ_HYDRO_DATES <- [load_area, site, date], 
  avg_hydro_flow ~ avg_flow, min_hydro_flow ~ min_flow, max_hydro_flow ~ max_flow;
read table hydro;

table proposed_renewable_sites IN: 
  PROJ_RESOURCE_LIMITED_SITES <- [load_area, technology, site], max_capacity, connect_cost_per_mw;
read table proposed_renewable_sites;

table cap_factor IN: 
  PROJ_INTERMITTENT_HOURS <- [load_area, technology, site, configuration, hour], cap_factor;
read table cap_factor;

table generator_info IN:  
	TECHNOLOGIES <- [technology], min_build_year, fuel, heat_rate, construction_time_years,
	max_age_years, forced_outage_rate, scheduled_outage_rate,
	intermittent, resource_limited, new_baseload ~ baseload, min_build_capacity, 
	min_dispatch_mw, min_runtime, min_downtime,	startup_fuel_mbtu;
read table generator_info;

table regional_generator_costs IN:  
	REGIONAL_TECHNOLOGIES <- [load_area, technology], price_year, overnight_cost,
	connect_cost_per_mw_generic, fixed_o_m, variable_o_m, overnight_cost_change,
	fixed_o_m_change, variable_o_m_change, nonfuel_startup_cost;
read table regional_generator_costs;

table fuel_costs IN:
	[load_area, fuel, year], fuel_price;
read table fuel_costs;

table fuel_info IN:
	FUELS <- [fuel], rps_fuel_category, carbon_content;
read table fuel_info;

table fuel_qualifies_for_rps IN:
	LOAD_AREAS_AND_FUEL_CATEGORY <- [load_area, rps_fuel_category], fuel_qualifies_for_rps ~ qualifies;
read table fuel_qualifies_for_rps; 


# parameter used to track execution times
param curtime;

# parameters used for reporting total generation and transmission

# name of the scenario
param scenario_id symbolic;
read scenario_id <scenario_id.txt;

# Whether or not to consider Renewable Portfolio Standards
read enable_rps < enable_rps.txt;

# years and hours to report
set STUDY_YEARS ordered = PERIODS;
param last_hour_of_year {y in STUDY_YEARS} = max {h in TIMEPOINTS: period[h]= y} h;
param first_hour_of_year {y in STUDY_YEARS} = min {h in TIMEPOINTS: period[h] = y} h;
param samples_in_year {y in STUDY_YEARS} = 
  card({h in TIMEPOINTS: period[h]=y});
set ZONAL_REPORTING_YEARS ordered = {last(STUDY_YEARS)};
set ZONAL_REPORTING_HOURS ordered = {h in TIMEPOINTS: period[h] in ZONAL_REPORTING_YEARS};

# parameters to report transmission and generation from various sources, in each load zone
set TECHNOLOGIES_INTERMITTENT = setof {t in TECHNOLOGIES: intermittent[t]} (t);
set TECHNOLOGIES_DISPATCH = setof {(z, t, s, o) in PROJ_DISPATCH} (t);
param total_gen {LOAD_AREAS, TECHNOLOGIES, STUDY_YEARS} default 0;
param surplus_gen {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT, STUDY_YEARS} default 0;
param intermittent_surplus_fraction {LOAD_AREAS, TIMEPOINTS} default 0;
param total_gen_installed {t in TECHNOLOGIES, y in STUDY_YEARS};
param total_trans {TRANSMISSION_LINES, STUDY_YEARS} default 0;
param avg_gen_by_zone {LOAD_AREAS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_zone {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_zone {LOAD_AREAS} default 0, >= 0;
param avg_gen_by_year {STUDY_YEARS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_year {STUDY_YEARS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_year {STUDY_YEARS} default 0, >= 0;
param power_cost_by_year {STUDY_YEARS} >= 0;
param outfile symbolic;

# Parameters for basicstats.run
param total_power_produced_by_period {PERIODS};


# Enable or disable policy constraints as needed. 
# This might be implemented better as named problems.
if enable_min_solar_production = 0 then {
	drop Min_Gen_Fraction_From_Solar;
}

if enable_rps = 0 then {
	drop Satisfy_RPS;
	drop Conservation_of_Blue_Electrons;
	drop Conservation_of_Colored_Electrons;
}


# Maximum potential from resource-limited sources
set RESOURCE_LIMITED_TECHNOLOGIES = setof{ t in TECHNOLOGIES: resource_limited[t] } (t);
param max_potential_power { t in RESOURCE_LIMITED_TECHNOLOGIES, p in PERIODS } = 
# Intermittent, resource-limited technologies
	# New plants
	sum{ (z, t, s, o) in PROJ_RESOURCE_LIMITED, h in TIMEPOINTS: 
	     period[h] = p and intermittent[t]} (
		(1-forced_outage_rate[t]) * max_capacity[z, t, s] * cap_factor[z, t, s, o, h] * hours_in_sample[h]
	)
	# Existing plants (assume they are operating)
  + sum { (z, e, h) in EP_INTERMITTENT_OPERATIONAL_HOURS: 
             period[h] = p and intermittent[t] and ep_technology[z,e] = t } (
        (1-ep_forced_outage_rate[z,e]) * eip_cap_factor[z, e, h]  * ep_size_mw[z, e] * hours_in_sample[h]
    )    
# Baseload, resource-limited technologies (currently biomass & geothermal)
	# New plants
  + sum { (z, t, s, o, v, h) in NEW_BASELOAD_VINTAGE_HOURS:
	      period[h] = p } ( 
    	(1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * max_capacity[z, t, s] * hours_in_sample[h]
    )
	# Existing plants (assume they are operating)
  + sum { (z, e, p) in EP_BASELOAD_PERIODS, h in TIMEPOINTS: 
          period[h] = p and ep_technology[z,e] = t} (
    	(1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] * hours_in_sample[h]
    )
# ToDo: add a part for dispatchable, resource-limited technologies when we add tech of that type
;
