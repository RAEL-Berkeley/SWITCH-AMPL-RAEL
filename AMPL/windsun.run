# note: this script should be called from a directory
# holding all the tab files.

reset;
if match($version, 'Darwin') > 0 then {
  #option solver cbc;
  # note: you also need to use codeweavers to open the ampl1 bottle and then call wine --cx-app=ilmd.exe
  option solver cplexamp;
#  Old setting for single-threaded execution
#  option cplex_options 'primalopt lpdisplay=1 mipdisplay=1';
# New settings for multi-threaded execution
#  option cplex_options 'lpdisplay=1 threads=8 mipdisplay=1';
  option cplex_options 'lpdisplay=1 iisfind=1 mipdisplay=1';
} else {
  option solver cplexamp;
#  Old setting for single-threaded execution
#  option cplex_options 'lpdisplay=1 threads=6 mipdisplay=1';
# New settings for multi-threaded execution
  option cplex_options 'lpdisplay=1 threads=8 mipdisplay=1';
}
option presolve 0;

model windsun.mod;

data windsun.dat;

table study_hours IN: TIMEPOINTS <- [hour], period, date, hours_in_sample, month_of_year, hour_of_day;
read table study_hours;

table load_areas IN: LOAD_AREAS <- [load_area], economic_multiplier, rps_compliance_year, rps_compliance_percentage;
read table load_areas;

table transmission_lines IN: 
  TRANSMISSION_LINES <- [load_area_start, load_area_end], existing_transfer_capacity_mw, transmission_line_id, 
  transmission_length_km, transmission_efficiency;
read table transmission_lines;

table system_load IN: [load_area, hour], system_load;
read table system_load;

table existing_plants IN: 
  EXISTING_PLANTS <- [load_area, plant_code], 
    ep_size_mw ~ size_mw, ep_technology ~ technology, ep_fuel ~ fuel, ep_heat_rate ~ heat_rate, 
    ep_vintage ~ start_year, ep_max_age_years ~ max_age, 
    ep_overnight_cost ~ overnight_cost, ep_fixed_o_m ~ fixed_o_m, ep_variable_o_m ~ variable_o_m,
    ep_forced_outage_rate ~ forced_outage_rate, ep_scheduled_outage_rate ~ scheduled_outage_rate, 
    ep_baseload ~ baseload, ep_cogen ~ cogen, ep_intermittent ~ intermittent;
read table existing_plants;

table existing_intermittent_plant_cap_factor IN: 
  EP_INTERMITTENT_HOURS <- [load_area, plant_code, hour], eip_cap_factor ~ cap_factor;
read table existing_intermittent_plant_cap_factor;

table hydro IN: 
  PROJ_HYDRO_DATES <- [load_area, site, date], 
  avg_hydro_flow ~ avg_flow, min_hydro_flow ~ min_flow, max_hydro_flow ~ max_flow;
read table hydro;

table proposed_renewable_sites IN: 
  PROJ_RESOURCE_LIMITED_SITES <- [load_area, technology, site], max_capacity, connect_cost_per_mw;
read table proposed_renewable_sites;

table cap_factor IN: 
  PROJ_INTERMITTENT_HOURS <- [load_area, technology, site, configuration, hour], cap_factor;
read table cap_factor;

table generator_info IN:  
	TECHNOLOGIES <- [technology], min_build_year, fuel, heat_rate, construction_time_years,
	max_age_years, forced_outage_rate, scheduled_outage_rate,
	intermittent, resource_limited, new_baseload ~ baseload, min_build_capacity, 
	min_dispatch_mw, min_runtime, min_downtime,	startup_fuel_mbtu;
read table generator_info;

table regional_generator_costs IN:  
	REGIONAL_TECHNOLOGIES <- [load_area, technology], price_year, overnight_cost,
	connect_cost_per_mw_generic, fixed_o_m, variable_o_m, overnight_cost_change,
	fixed_o_m_change, variable_o_m_change, nonfuel_startup_cost;
read table regional_generator_costs;

table fuel_costs IN:
	[load_area, fuel, year], fuel_price;
read table fuel_costs;

table fuel_info IN:
	FUELS <- [fuel], rps_fuel_category, carbon_content;
read table fuel_info;

table fuel_qualifies_for_rps IN:
	LOAD_AREAS_AND_FUEL_CATEGORY <- [load_area, rps_fuel_category], fuel_qualifies_for_rps ~ qualifies;
read table fuel_qualifies_for_rps; 


# parameter used to track execution times
param curtime;

# parameters used for reporting total generation and transmission

# name of the scenario
param scenario_id symbolic;
read scenario_id <scenario_id.txt;

# Whether or not to consider Renewable Portfolio Standards
read enable_rps < enable_rps.txt;

# years and hours to report
set STUDY_YEARS ordered = PERIODS;
param last_hour_of_year {y in STUDY_YEARS} = max {h in TIMEPOINTS: period[h]= y} h;
param first_hour_of_year {y in STUDY_YEARS} = min {h in TIMEPOINTS: period[h] = y} h;
param samples_in_year {y in STUDY_YEARS} = 
  card({h in TIMEPOINTS: period[h]=y});
set ZONAL_REPORTING_YEARS ordered = {last(STUDY_YEARS)};
set ZONAL_REPORTING_HOURS ordered = {h in TIMEPOINTS: period[h] in ZONAL_REPORTING_YEARS};

# parameters to report transmission and generation from various sources, in each load zone
set TECHNOLOGIES_INTERMITTENT = setof {t in TECHNOLOGIES: intermittent[t]} (t);
set TECHNOLOGIES_DISPATCH = setof {(z, t, s, o) in PROJ_DISPATCH} (t);
param total_gen {LOAD_AREAS, TECHNOLOGIES, STUDY_YEARS} default 0;
param surplus_gen {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT, STUDY_YEARS} default 0;
param intermittent_surplus_fraction {LOAD_AREAS, TIMEPOINTS} default 0;
param total_gen_installed {t in TECHNOLOGIES, y in STUDY_YEARS};
param total_trans {TRANSMISSION_LINES, STUDY_YEARS} default 0;
param avg_gen_by_zone {LOAD_AREAS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_zone {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_zone {LOAD_AREAS} default 0, >= 0;
param avg_gen_by_year {STUDY_YEARS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_year {STUDY_YEARS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_year {STUDY_YEARS} default 0, >= 0;
param power_cost_by_year {STUDY_YEARS} >= 0;
param outfile symbolic;

# Parameters for basicstats.run
param total_load_last_period := (sum {z in LOAD_AREAS, h in TIMEPOINTS: period[h]=last(PERIODS)} system_load[z, h] * hours_in_sample[h]);
param total_power_produced_last_period;
