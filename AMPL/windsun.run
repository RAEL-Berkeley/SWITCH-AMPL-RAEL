# note: this script should be called from a directory
# holding all the tab files.

reset;
option solver cplexamp;
option cplex_options 'lpdisplay=1 iisfind=1 mipdisplay=1';
# Other options
# Add 'threads=8' for multi-threaded execution.
# Adding 'advance=2' might speed up solutions that work from a similar problem's solution
option presolve 0;

# parameter used to track execution times and other management stuff.
param curtime;
param cost_sol_time;
param trans_sol_time;
param solution_times_path symbolic = "results/run_times.txt";
param file_exists;

model windsun.mod;
set RESULT_FILES;
param result_file_path_templates{RESULT_FILES} symbolic;
param result_header_paths{RESULT_FILES} symbolic;
param output_section symbolic;

data windsun.dat;

table study_hours IN: 
  TIMEPOINTS <- [hour], period, date, hours_in_sample, month_of_year, hour_of_day;
read table study_hours;

table load_areas IN: 
  LOAD_AREAS <- [load_area], load_area_id, economic_multiplier, rps_compliance_year, rps_compliance_percentage;
read table load_areas;

table transmission_lines IN: 
  TRANSMISSION_LINES <- [load_area_start, load_area_end], existing_transfer_capacity_mw, transmission_line_id, 
  transmission_length_km, transmission_efficiency;
read table transmission_lines;

table system_load IN: 
  [load_area, hour], system_load;
read table system_load;

table existing_plants IN: 
  EXISTING_PLANTS <- [load_area, plant_code], ep_project_id, 
    ep_size_mw ~ size_mw, ep_technology ~ technology, ep_fuel ~ fuel, ep_heat_rate ~ heat_rate, 
    ep_vintage ~ start_year, ep_max_age_years ~ max_age, 
    ep_overnight_cost ~ overnight_cost, ep_fixed_o_m ~ fixed_o_m, ep_variable_o_m ~ variable_o_m,
    ep_forced_outage_rate ~ forced_outage_rate, ep_scheduled_outage_rate ~ scheduled_outage_rate, 
    ep_baseload ~ baseload, ep_cogen ~ cogen, ep_intermittent ~ intermittent;
read table existing_plants;

table existing_intermittent_plant_cap_factor IN: 
  EP_INTERMITTENT_HOURS <- [load_area, plant_code, hour], eip_cap_factor ~ cap_factor;
read table existing_intermittent_plant_cap_factor;

table hydro IN: 
  PROJ_HYDRO_DATES <- [load_area, hydro_project_id, date], hydro_site ~ site_id, 
  avg_hydro_flow ~ avg_flow, min_hydro_flow ~ min_flow, max_hydro_flow ~ max_flow;
read table hydro;

table proposed_projects IN: 
  PROJECTS <- [project_id, load_area, technology], project_location ~ location_id, 
    capacity_limit, capacity_limit_conversion, connect_cost_per_mw, price_and_dollar_year, 
    overnight_cost, fixed_o_m, variable_o_m, overnight_cost_change, nonfuel_startup_cost;
read table proposed_projects;

# If a project's location id is 0, it means that project hasn't been assigned a geographic location that is more specific than a load area.
for {(pid, a, t) in PROJECTS: project_location[pid, a, t] == 0} {
	let project_location[pid, a, t] := location_unspecified;
}

table competing_locations IN:
	LOCATIONS_WITH_COMPETING_TECHNOLOGIES <- [location_id];
read table competing_locations;


table cap_factor IN: 
  PROJ_INTERMITTENT_HOURS <- [project_id, load_area, technology, hour], cap_factor;
read table cap_factor;

table generator_info IN:  
	TECHNOLOGIES <- [technology], technology_id, min_build_year, fuel, heat_rate, construction_time_years,
 	year_1_cost_fraction, year_2_cost_fraction, year_3_cost_fraction, year_4_cost_fraction, year_5_cost_fraction, year_6_cost_fraction,
	max_age_years, forced_outage_rate, scheduled_outage_rate,
	intermittent, resource_limited, new_baseload ~ baseload, min_build_capacity, 
	min_dispatch_fraction, min_runtime, min_downtime, max_ramp_rate_mw_per_hour, startup_fuel_mbtu;
read table generator_info;

# Mark which technologies will be competing for space
for { t in SOLAR_CSP_TECHNOLOGIES } {
  let technologies_compete_for_space[t] := 1;
}
let technologies_compete_for_space['Central_PV'] := 1;

#table generator_costs_regional IN:  
#	REGIONAL_TECHNOLOGIES <- [load_area, technology], regional_project_id, price_and_dollar_year, overnight_cost,
#	connect_cost_per_mw_generic, fixed_o_m, variable_o_m, overnight_cost_change,
#	nonfuel_startup_cost;
#read table generator_costs_regional;

table fuel_costs IN:
	[load_area, fuel, year], fuel_price;
read table fuel_costs;

table fuel_info IN:
	FUELS <- [fuel], rps_fuel_category, carbon_content;
read table fuel_info;

table fuel_qualifies_for_rps IN:
	LOAD_AREAS_AND_FUEL_CATEGORY <- [load_area, rps_fuel_category], fuel_qualifies_for_rps ~ qualifies;
read table fuel_qualifies_for_rps; 

###################################
# parameters used for reporting total generation and transmission

# name of the scenario
param scenario_id symbolic;
read scenario_id <scenario_id.txt;

# Whether or not to consider Renewable Portfolio Standards
read enable_rps < enable_rps.txt;

# years and hours to report
set STUDY_YEARS ordered = PERIODS;
param last_hour_of_year {y in STUDY_YEARS} = max {h in TIMEPOINTS: period[h]= y} h;
param first_hour_of_year {y in STUDY_YEARS} = min {h in TIMEPOINTS: period[h] = y} h;
param samples_in_year {y in STUDY_YEARS} = 
  card({h in TIMEPOINTS: period[h]=y});
set ZONAL_REPORTING_YEARS ordered = {last(STUDY_YEARS)};
set ZONAL_REPORTING_HOURS ordered = {h in TIMEPOINTS: period[h] in ZONAL_REPORTING_YEARS};

# parameters to report transmission and generation from various sources, in each load zone
set TECHNOLOGIES_INTERMITTENT = setof {t in TECHNOLOGIES: intermittent[t]} (t);
set TECHNOLOGIES_DISPATCH = setof {(pid, a, t) in PROJ_DISPATCH} (t);
param total_gen {LOAD_AREAS, TECHNOLOGIES, STUDY_YEARS} default 0;
param surplus_gen {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT, STUDY_YEARS} default 0;
param intermittent_surplus_fraction {LOAD_AREAS, TIMEPOINTS} default 0;
param total_gen_installed {t in TECHNOLOGIES, y in STUDY_YEARS};
param total_trans {TRANSMISSION_LINES, STUDY_YEARS} default 0;
param avg_gen_by_zone {LOAD_AREAS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_zone {LOAD_AREAS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_zone {LOAD_AREAS} default 0, >= 0;
param avg_gen_by_year {STUDY_YEARS, TECHNOLOGIES} default 0, >= 0;
param avg_surp_by_year {STUDY_YEARS, TECHNOLOGIES_INTERMITTENT} default 0, >= 0;
param avg_load_by_year {STUDY_YEARS} default 0, >= 0;
param power_cost_by_year {STUDY_YEARS} >= 0;
param outfile symbolic;

# Parameters for basicstats.run
param total_power_produced_by_period {PERIODS};
param transmission_losses_by_period {PERIODS};


# Enable or disable policy constraints as needed. 
# This might be implemented better as named problems.
if enable_min_solar_production = 0 then {
	drop Min_Gen_Fraction_From_Solar;
}

redeclare param rps_fuel_category {FUELS} symbolic;
if (enable_rps = 0) then {
	drop Satisfy_RPS;
	drop Conservation_of_Blue_Electrons;
	drop Conservation_of_Colored_Electrons;
	let LOAD_AREAS_AND_FUEL_CATEGORY := setof{l in LOAD_AREAS} (l,'na');
	let {f in FUELS} rps_fuel_category[f] := 'na';
} 
redeclare param rps_fuel_category {FUELS} symbolic in RPS_FUEL_CATEGORY;

# Maximum potential from resource-limited sources
set RESOURCE_LIMITED_TECHNOLOGIES = setof{ t in TECHNOLOGIES: resource_limited[t] } (t);
param max_potential_power {FUELS, PERIODS };
if ( enable_min_solar_production = 1 ) then {

  for { f in FUELS, yr in PERIODS } {
  let max_potential_power[ f, yr ] := 
	sum{ t in RESOURCE_LIMITED_TECHNOLOGIES: fuel[t] = f and intermittent[t] } (
	# Intermittent, resource-limited projects that are not located at sites where technologies are in competition
		# New plants
		sum{ (pid, a, t) in PROJ_RESOURCE_LIMITED, h in TIMEPOINTS: 
			 period[h] = yr and fuel[t] = f and not (project_location[pid, a, t] in LOCATIONS_WITH_COMPETING_TECHNOLOGIES)} (
			(1-forced_outage_rate[t]) * capacity_limit[pid, a, t] * capacity_limit_conversion[pid, a, t] * cap_factor[pid, a, t, h] * hours_in_sample[h]
		)
		# Existing plants (assume they are operating)
	  + sum { (a, e, h) in EP_INTERMITTENT_OPERATIONAL_HOURS: 
				 period[h] = yr and ep_technology[a,e] = t and ep_fuel[a,e]=f} (
			(1-ep_forced_outage_rate[a,e]) * eip_cap_factor[a, e, h]  * ep_size_mw[a, e] * hours_in_sample[h]
		)
	# New Intermittent, resource-limited projects that are located at sites with competing technologies. 
	# Pick the technology that if installed completely would provide the most power. 
	# This assumes that competing technologies share the same fuel
	  + sum{ l in LOCATIONS_WITH_COMPETING_TECHNOLOGIES } 
		  max{(pid, a, t) in PROJ_RESOURCE_LIMITED, h in TIMEPOINTS: 
			 period[h] = yr and fuel[t] = f and project_location[pid, a, t] = l }
			 (1-forced_outage_rate[t]) * capacity_limit[pid, a, t] * capacity_limit_conversion[pid, a, t] * cap_factor[pid, a, t, h] * hours_in_sample[h]
	
	# Baseload, resource-limited technologies (currently biomass & geothermal)
		# New plants
	  + sum { (pid, a, t, v, h) in NEW_BASELOAD_VINTAGE_HOURS:
			  period[h] = yr and fuel[t] = f } ( 
			(1-forced_outage_rate[t]) * (1-scheduled_outage_rate[t]) * capacity_limit[pid, a, t] * capacity_limit_conversion[pid, a, t] * hours_in_sample[h]
		)
		# Existing plants (assume they are operating)
	  + sum { (a, e, yr) in EP_BASELOAD_PERIODS, h in TIMEPOINTS: 
			  period[h] = yr and ep_technology[a,e] = t and ep_fuel[a,e]=f} (
			(1-ep_forced_outage_rate[a, e]) * (1-ep_scheduled_outage_rate[a, e]) * ep_size_mw[a, e] * hours_in_sample[h]
		)
	# ToDo: add a part for dispatchable, resource-limited technologies when we add tech of that type
	)
	;
  }
}
check;

