# note: this script should be called from a directory
# holding all the tab files.

reset;
option solver cplexamp;
param scenario_id symbolic;

############################################################
#
# Utility Functions that interact with the operating system
#
# get_num_cores() determines how many processor cores are on the current machine. Works on OS X & Linux.
function get_num_cores pipe "while read junk; do if [ `uname` == 'Darwin' ]; then sysctl hw.ncpu | awk '{print $2}'; elif [ `uname` == 'Linux' ]; then cat /proc/cpuinfo | grep processor | wc -l | awk '{print $1}'; else echo 1; fi; done;";
# file_exists(file_path) determines whether a file exists at the specified path (relative or absolute). Returns a 1 or a 0. Works on OS X & Linux.
function file_exists pipe 'while read file_path; do if [ -f "$file_path" ]; then echo 1; else echo 0; fi; done;';
param num_workers default 1;
param worker_id default 0;
param compile_mip_only default 0;



option cplex_options (" lpdisplay=1 iisfind=1 mipdisplay=2 presolve=1 prestats=1 timing=1 nodefile=2 treememory=15000 threads=" & get_num_cores() );

# Other options
# Add 'threads=8' for multi-threaded execution.
# Adding 'advance=2' might speed up solutions that work from a similar problem's solution
option presolve 0;
option presolve_eps 1e-10;
# Options to enable automatic substitution of variables without making the program non-linear
option substout 1, linelim 1;
# Options to enable timing of compilation
# option show_stats 1, times 1, gentimes 1;
# Options to print out auxiliary files from ampl of the compiled MIP - see p. 488 of the AMPL book for documentation
# option auxfiles cfrsu;


# parameter used to track execution times and other management stuff.
param curtime;
param cost_compile_time default -1;
param cost_sol_time default -1;
param trans_sol_time default -1;
param solution_times_path symbolic = "results/run_times.txt";
param results_path symbolic := 'results/';
# Make the results directory if it doesn't exist.
shell("if [ ! -d " & results_path & " ]; then mkdir " & results_path & "; fi");

model windsun.mod;
set RESULT_FILES;
param result_file_path_templates{RESULT_FILES} symbolic;
param result_header_paths{RESULT_FILES} symbolic;
param output_section symbolic;
data windsun.dat;
data inputs/misc_params.dat;
param outfile symbolic;

#########################
# Define two "Problems": Investment optimization (with dispatch considerations) and Transmission minimization.
problem Cost_Minimization: 
  # Objective function 
	Power_Cost, 

  # Satisfy Load and Power Consumption
    Satisfy_Load,
	Conservation_Of_Energy_NonDistributed, Conservation_Of_Energy_Distributed,
    ConsumeNonDistributedPower, ConsumeDistributedPower, RedirectDistributedPower,
  # Investment Decisions
	InstallGen, InstallGenTotal, BuildGenOrNot, InstallTrans, InstallLocalTD, 
  # Installation Constraints
	Maximum_Resource_Competing_Tech, Maximum_Resource_Location_Unspecified, Minimum_GenSize, BuildGenOrNot_Constraint, SymetricalTrans, Minimum_LocalTD, 

  # Dispatch Decisions
	DispatchGen, OperateEPDuringPeriod, ProducePowerEP, ConsumeBioSolid, DispatchTransFromXToY, StoreEnergy, ReleaseEnergy,
	Dispatch_NonPumped_Hydro, Dispatch_Pumped_Hydro_Watershed_Electrons, Dispatch_Pumped_Hydro_Storage, Store_Pumped_Hydro,
  # Dispatch Constraints
	Power_From_Dispatchable_Plants,
	EP_Operational_Continuity, EP_Power_From_Dispatchable_Plants, EP_Power_From_Intermittent_Plants, EP_Power_From_Baseload_Plants,
	Bio_Solid_Consumption, Carbon_Cap,
	Maximum_DispatchTransFromXToY, Maximum_DispatchTransFromXToY_Reserve, 
	Maximum_Dispatch_NonPumped_Hydro, Average_NonPumped_Hydro_Output,        Minimum_Dispatch_NonPumped_Hydro, 
	Maximum_Dispatch_Pumped_Hydro,    Average_Pumped_Hydro_Watershed_Output,
	Maximum_Store_Pumped_Hydro, Conservation_Of_Stored_Pumped_Hydro_Electrons,
	CAES_Combined_Dispatch, Maximum_Store_Rate, Maximum_Release_Storage_Rate, Storage_Projects_Energy_Balance, 

  # Contigency Planning Variables (to ensure that a dispatch plan exists that can meet reserve margins)
	DispatchTransFromXToY_Reserve, StoreEnergy_Reserve, ReleaseEnergy_Reserve, 
	Dispatch_NonPumped_Hydro_Reserve, Dispatch_Pumped_Hydro_Watershed_Electrons_Reserve, Dispatch_Pumped_Hydro_Storage_Reserve, Store_Pumped_Hydro_Reserve, 
  # Contigency Planning constraints
	Satisfy_Load_Reserve, 
	Conservation_Of_Energy_NonDistributed_Reserve, Conservation_Of_Energy_Distributed_Reserve,
    ConsumeNonDistributedPower_Reserve, ConsumeDistributedPower_Reserve, RedirectDistributedPower_Reserve,
  # Dispatch Reserve Constraints
	Maximum_Dispatch_NonPumped_Hydro_Reserve, Average_NonPumped_Hydro_Output_Reserve,        Minimum_Dispatch_NonPumped_Hydro_Reserve, 
	Maximum_Dispatch_Pumped_Hydro_Reserve,    Average_Pumped_Hydro_Watershed_Output_Reserve,
	Maximum_Store_Pumped_Hydro_Reserve, Conservation_Of_Stored_Pumped_Hydro_Electrons_Reserve,
	Maximum_Store_Rate_Reserve, Maximum_Release_Storage_Rate_Reserve, Storage_Projects_Energy_Balance_Reserve
;


problem Cost_Minimization;
# Add policy constraints as needed.
if (enable_rps = 1                 ) then { restore Satisfy_RPS; };

table study_hours "inputs/study_hours.tab" IN: 
  TIMEPOINTS <- [hour], period, date, hours_in_sample, month_of_year, hour_of_day;
read table study_hours;

table load_areas "inputs/load_areas.tab" IN: 
  LOAD_AREAS <- [load_area], load_area_id, economic_multiplier, 
  	max_coincident_load_for_local_td, local_td_new_annual_payment_per_mw, local_td_sunk_annual_payment, transmission_sunk_annual_payment;
read table load_areas;

table rps_load_area_targets "inputs/rps_load_area_targets.tab" IN: 
  [load_area, rps_compliance_year], rps_compliance_fraction;
read table rps_load_area_targets;

table carbon_cap_targets "inputs/carbon_cap_targets.tab" IN: 
  [year], carbon_emissions_relative_to_base;
read table carbon_cap_targets;

table transmission_lines "inputs/transmission_lines.tab" IN: 
  TRANSMISSION_LINES <- [load_area_start, load_area_end], existing_transfer_capacity_mw, transmission_line_id, 
  transmission_length_km, transmission_efficiency, new_transmission_builds_allowed;
read table transmission_lines;

table system_load "inputs/system_load.tab" IN: 
  [load_area, hour], system_load;
read table system_load;

table existing_plants "inputs/existing_plants.tab" IN: 
  EXISTING_PLANTS <- [load_area, plant_code], ep_project_id, 
    ep_size_mw ~ size_mw, ep_technology ~ technology, ep_fuel ~ fuel, ep_heat_rate ~ heat_rate, 
    ep_vintage ~ start_year, ep_max_age_years ~ max_age, 
    ep_overnight_cost ~ overnight_cost, ep_fixed_o_m ~ fixed_o_m, ep_variable_o_m ~ variable_o_m,
    ep_forced_outage_rate ~ forced_outage_rate, ep_scheduled_outage_rate ~ scheduled_outage_rate, 
    ep_baseload ~ baseload, ep_cogen ~ cogen, ep_intermittent ~ intermittent;
read table existing_plants;

table existing_intermittent_plant_cap_factor "inputs/existing_intermittent_plant_cap_factor.tab" IN: 
  EP_INTERMITTENT_HOURS <- [load_area, plant_code, period, hour], eip_cap_factor ~ cap_factor;
read table existing_intermittent_plant_cap_factor;

table hydro "inputs/hydro.tab" IN: 
  PROJ_HYDRO_DATES <- [load_area, hydro_project_id, date], hydro_technology ~ technology, hydro_technology_id ~ technology_id, 
  hydro_capacity_mw ~ capacity_mw, avg_hydro_output ~ avg_output;
read table hydro;

table proposed_projects "inputs/proposed_projects.tab" IN: 
  PROJECTS <- [project_id, load_area, technology], project_location ~ location_id, 
    capacity_limit, capacity_limit_conversion, connect_cost_per_mw, price_and_dollar_year, 
    overnight_cost, fixed_o_m, variable_o_m, overnight_cost_change;
read table proposed_projects;

# If a project's location id is 0, it means that project hasn't been assigned a geographic location that is more specific than a load area.
for {(pid, a, t) in PROJECTS: project_location[pid, a, t] == 0} {
	let project_location[pid, a, t] := location_unspecified;
}

table competing_locations "inputs/competing_locations.tab" IN:
	LOCATIONS_WITH_COMPETING_TECHNOLOGIES <- [location_id, load_area];
read table competing_locations;


table cap_factor "inputs/cap_factor.tab" IN: 
  PROJ_INTERMITTENT_HOURS <- [project_id, load_area, technology, period, hour], cap_factor;
read table cap_factor;

table generator_info "inputs/generator_info.tab" IN:  
	TECHNOLOGIES <- [technology], technology_id, min_build_year, fuel, heat_rate, construction_time_years,
 	year_1_cost_fraction, year_2_cost_fraction, year_3_cost_fraction, year_4_cost_fraction, year_5_cost_fraction, year_6_cost_fraction,
	max_age_years, forced_outage_rate, scheduled_outage_rate,
	can_build_new, ccs, intermittent, resource_limited, baseload, min_build_capacity, 
	storage, storage_efficiency, max_store_rate;
read table generator_info;

# Mark which technologies will be competing for space
for { t in SOLAR_CSP_TECHNOLOGIES } {
  let technologies_compete_for_space[t] := 1;
}
let technologies_compete_for_space['Central_PV'] := 1;
let technologies_compete_for_space['Concentrating_PV'] := 1;
let technologies_compete_for_space['Biomass_IGCC'] := 1;
let technologies_compete_for_space['Biomass_IGCC_CCS'] := 1;
let technologies_compete_for_space['Bio_Gas'] := 1;
let technologies_compete_for_space['Bio_Gas_CCS'] := 1;

table fuel_costs "inputs/fuel_costs.tab" IN:
	[load_area, fuel, year], fuel_price;
read table fuel_costs;

table biomass_supply_curve_slope "inputs/biomass_supply_curve_slope.tab" IN:
	LOAD_AREAS_AND_BIO_BREAKPOINTS <- [load_area, breakpoint_id], price_dollars_per_mbtu;
read table biomass_supply_curve_slope;

table biomass_supply_curve_breakpoint "inputs/biomass_supply_curve_breakpoint.tab" IN:
	[load_area, breakpoint_id], breakpoint_mbtus_per_year;
read table biomass_supply_curve_breakpoint;

table fuel_info "inputs/fuel_info.tab" IN:
	FUELS <- [fuel], rps_fuel_category, carbon_content;
read table fuel_info;
let FUELS := FUELS union {"Storage"};

table fuel_qualifies_for_rps "inputs/fuel_qualifies_for_rps.tab" IN:
	LOAD_AREAS_AND_FUEL_CATEGORY <- [load_area, rps_fuel_category], fuel_qualifies_for_rps ~ qualifies;
read table fuel_qualifies_for_rps; 


###################################
redeclare param rps_fuel_category {FUELS} symbolic;
if (enable_rps = 0) then {
	drop Satisfy_RPS;
	let LOAD_AREAS_AND_FUEL_CATEGORY := setof{a in LOAD_AREAS} (a,'na');
	let {f in FUELS} rps_fuel_category[f] := 'na';
} 
redeclare param rps_fuel_category {FUELS} symbolic in RPS_FUEL_CATEGORY;

if (enable_carbon_cap = 0) then {
	drop Carbon_Cap;
} 

check;

# create cost fraction parameter for cost calculations and discounting for new and existing plants
# param cost_fraction { t in TECHNOLOGIES, yr in YEAR_OF_CONSTRUCTION };
for { t in TECHNOLOGIES } {
	let cost_fraction[t,0] := year_1_cost_fraction[t];
	let cost_fraction[t,1] := year_2_cost_fraction[t];
	let cost_fraction[t,2] := year_3_cost_fraction[t];
	let cost_fraction[t,3] := year_4_cost_fraction[t];
	let cost_fraction[t,4] := year_5_cost_fraction[t];
	let cost_fraction[t,5] := year_6_cost_fraction[t];
}
;

###################################
# parameters used for reporting total generation and transmission
param Capital_Payments_by_Plant_and_Period { (pid, a, t, p) in PROJECT_VINTAGES }; 
param EP_Capital_Payments_by_Plant_and_Period { (a, e, p) in EP_PERIODS }; 
param Fixed_OM_by_Plant_and_Period { (pid, a, t, p) in PROJECT_VINTAGES };  
param EP_Fixed_OM_by_Plant_and_Period { (a, e, p) in EP_PERIODS }; 
param NonPumped_Hydro_Capital_Payments_by_Plant_and_Period { (a, pid) in PROJ_NONPUMPED_HYDRO, p in PERIODS };
param NonPumped_Hydro_Fixed_OM_by_Plant_and_Period  { (a, pid) in PROJ_NONPUMPED_HYDRO, p in PERIODS };
param NonPumped_Hydro_Variable_Cost_Incurred_Hourly { (a, pid) in PROJ_NONPUMPED_HYDRO, h in TIMEPOINTS };
param Pumped_Hydro_Capital_Payments_by_Plant_and_Period { (a, pid) in PROJ_PUMPED_HYDRO, p in PERIODS }; 
param Pumped_Hydro_Fixed_OM_by_Plant_and_Period { (a, pid) in PROJ_PUMPED_HYDRO, p in PERIODS }; 
param Carbon_Emissions { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: t <> 'Battery_Storage' }; 
param EP_Carbon_Emissions { (a, e, p, h) in EP_AVAILABLE_HOURS }; 
param Carbon_Cost_Incurred_Hourly { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: t <> 'Battery_Storage' }; 
param EP_Carbon_Cost_Incurred_Hourly { (a, e, p, h) in EP_AVAILABLE_HOURS }; 
param Biomass_Solid_Fuel_Cost { a in LOAD_AREAS, h in TIMEPOINTS: num_bio_breakpoints[a] > 0 };
param Fuel_Cost_Incurred_Hourly { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: t <> 'Battery_Storage' }; 
param EP_Fuel_Cost_Incurred_Hourly { (a, e, p, h) in EP_AVAILABLE_HOURS }; 
param Variable_Cost_Incurred_Hourly { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: t <> 'Battery_Storage' }; 
param Storage_Variable_Cost_Incurred_Hourly { (pid, a, t, p, h) in PROJECT_VINTAGE_HOURS: storage[t] }; 
param EP_Variable_Cost_Incurred_Hourly { (a, e, p, h) in EP_AVAILABLE_HOURS }; 
param Local_TD_Existing_Cost_Per_Period { a in LOAD_AREAS, p in PERIODS };
param Local_TD_New_Cost_Per_Period { a in LOAD_AREAS, p in PERIODS };
param Transmission_Existing_Cost_Per_Period { a in LOAD_AREAS, p in PERIODS };
param Transmission_New_Cost_Per_Period { (a1, a2) in TRANSMISSION_LINES, p in PERIODS };
param Power_Cost_Per_Period {p in PERIODS};
param Carbon_Costs_Per_Period_per_MWh {p in PERIODS};
param Yearly_Carbon_Emissions {p in PERIODS};
param Gross_Power_by_Period {p in PERIODS}; 
param Transmission_Losses_by_Period {p in PERIODS};
param Distribution_Losses_by_Period {p in PERIODS};
param Storage_Losses_by_Period {p in PERIODS};
param system_load_discounted;



