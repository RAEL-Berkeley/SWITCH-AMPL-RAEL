include load.run;

# This is a test of subversion. this is only a test. Beeeeeeeeeeeeeep

for {c in CARBON_COSTS} {
  let carbon_cost := c;

  solution ("results/sol" & carbon_cost & "cost.sol");

  # move to the transmission-minimizing version
  fix InstallGen;
  fix DispatchGen;
#  fix DispatchSystemLoad;
  fix OperateEPDuringYear;
  fix DispatchEP;
  fix InstallTrans;
  fix DispatchTransTo_Reserve;
  fix DispatchTransFrom_Reserve;
  fix InstallLocalTD;
  fix StorePumpedHydro;
  fix DispatchPumpedHydro;
  fix StorePumpedHydro_Reserve;
  fix DispatchPumpedHydro_Reserve;
  fix HydroDispatchShare;
  fix HydroDispatchShare_Reserve;
  objective Transmission_Usage;
  option presolve_eps 1e-10;

  #solution ("results/sol" & carbon_cost & "trans.sol");
  write ("b" & "results/sol" & carbon_cost & "trans");
  solve;
  
  unfix InstallGen;
  unfix DispatchGen;
#  unfix DispatchSystemLoad;
  unfix OperateEPDuringYear;
  unfix DispatchEP;
  unfix InstallTrans;
  unfix DispatchTransTo_Reserve;
  unfix DispatchTransFrom_Reserve;
  unfix InstallLocalTD;
  unfix StorePumpedHydro;
  unfix DispatchPumpedHydro;
  unfix StorePumpedHydro_Reserve;
  unfix DispatchPumpedHydro_Reserve;
  unfix HydroDispatchShare;
  unfix HydroDispatchShare_Reserve;

  include basicstats.run;

  let curtime := time();



########################## Begin code from record_results.run


#######################
# store all hourly generation data in standardized, MW terms

# hourly power production from each source
# as well as total CO2 emissions per hour, heat rate, variable costs per MWh
# It might be better to report sub-components (CO2_per_mwh, variable_o_m and fuel_cost_hourly) instead of total emissions and variable costs
# (that would simplify the code here, but then the components would have to be multiplied and added in mysql later)
let outfile := "results/power_" & carbon_cost & ".csv";
printf "scenario_name,carbon_cost,period,load_area,date,hour,technology,site,orientation,new,baseload,cogen,fuel,power,co2_tons,hours_in_sample,heat_rate,fuel_cost_tot,carbon_cost_tot,variable_o_m_tot\n"
  > (outfile);

# new dispatchable projects
# (21 seconds, 1.5 MB)
printf {(z, t, s, o) in PROJ_DISPATCH, h in HOURS} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, period[h], z, date[h], h, t, s, o, 1, 0, 0, fuel[t], 
  DispatchGen[z, t, s, o, h], 
  DispatchGen[z, t, s, o, h] * heat_rate[t]/1000 * carbon_content[fuel[t]],
  hours_in_sample[h],
  heat_rate[t], 
  DispatchGen[z, t, s, o, h] * heat_rate[t]/1000 * fuel_cost_hourly[fuel[t], h],
  DispatchGen[z, t, s, o, h] * heat_rate[t]/1000 * carbon_content[fuel[t]] * carbon_cost,
  DispatchGen[z, t, s, o, h] * variable_o_m[z,t]
  >> (outfile);


# new intermittent projects (all renewables, so no carbon emissions)
# (takes 114 seconds, 3 MB)
# note: we only report the total for each zone; totals for each site can be derived directly from the decision variables
printf {(z, t) in setof {(z1, t1, s1, o1) in PROJ_INTERMITTENT} (z1, t1), h in HOURS, p in PERIODS: period[h]=p}
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, t, "na", "na", 1, 0, 0, fuel[t], 
  (sum {(z, t, s, o, v, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * cap_factor[z, t, s, o, h] * InstallGen[z, t, s, o, v]),
  0,
  hours_in_sample[h],
  0, 
  0, 0,
  (sum {(z, t, s, o, v, h) in PROJ_INTERMITTENT_VINTAGE_HOURS} 
    (1-forced_outage_rate[t]) * cap_factor[z, t, s, o, h] * InstallGen[z, t, s, o, v]) * variable_o_m[z,t]
  >> (outfile);

# existing baseload plants
# (takes 178 seconds, 6 MB)
printf {(z, e, p) in EP_BASELOAD_PERIODS, h in HOURS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", e, "na", 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  OperateEPDuringYear[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e],
  OperateEPDuringYear[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e]/1000 * carbon_content[ep_fuel[z, e]],
  hours_in_sample[h],
  ep_heat_rate[z, e], 
  OperateEPDuringYear[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e]/1000 * fuel_cost_hourly[ep_fuel[z, e], h],
  OperateEPDuringYear[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e] 
    * ep_heat_rate[z, e]/1000 * carbon_content[ep_fuel[z, e]] * carbon_cost,
  OperateEPDuringYear[z, e, p] * (1-ep_forced_outage_rate[z, e]) * (1-ep_scheduled_outage_rate[z, e]) * ep_size_mw[z, e]
    * ep_variable_o_m[z, e]
  >> (outfile);

# existing dispatchable plants
# (takes 109 seconds, 4 MB)
printf {(z, e, h) in EP_DISPATCH_HOURS, p in PERIODS: p=period[h]} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", e, "na", 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  DispatchEP[z, e, h],
  DispatchEP[z, e, h] * ep_heat_rate[z, e] * carbon_content[ep_fuel[z, e]] / 1000,
  hours_in_sample[h],
  ep_heat_rate[z, e], 
  DispatchEP[z, e, h]
    * ep_heat_rate[z, e]/1000 * fuel_cost_hourly[ep_fuel[z, e], h],
  DispatchEP[z, e, h]
    * ep_heat_rate[z, e]/1000 * carbon_content[ep_fuel[z, e]] * carbon_cost,
  DispatchEP[z, e, h]
    * ep_variable_o_m[z, e]
  >> (outfile);

# hydro pumping (6 sec)
printf {(z, s) in PROJ_PUMPED_HYDRO, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", s, "na", 0, 0, 0, "Hydro Pumping",
  -1 * (1 - forced_outage_rate_hydro) * (1/pumped_hydro_efficiency) * StorePumpedHydro[z, s, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# hydro dispatch
# (61 s, 6 MB)
printf {(z, s) in PROJ_PUMPED_HYDRO, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", s, "na", 0, 0, 0, "Hydro",
  (1 - forced_outage_rate_hydro) * DispatchPumpedHydro[z, s, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);
printf {z in LOAD_ZONES, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", "simple_hydro", "na", 0, 0, 0, "Hydro",
  (1 - forced_outage_rate_hydro) * 
   (min_hydro_dispatch_all_sites[z, date[h]] 
      + HydroDispatchShare[p, z, season_of_year[h], hour_of_day[h]]
        * (avg_hydro_dispatch_all_sites[z, date[h]] - min_hydro_dispatch_all_sites[z, date[h]]) * 24),
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# total imports and exports
# (38 seconds, 2 MB)
printf {z in LOAD_ZONES, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", "Transmission", "na", 0, 0, 0, "na",
#  (1-transmission_forced_outage_rate) *  
#    (sum {(z, z2) in TRANS_LINES} transmission_efficiency[z, z2] * (existing_transmission[z, z2] + sum {(z, z2, v, h) in TRANS_VINTAGE_HOURS} #InstallTrans[z, z2, v])
#    + sum {(z1, z) in TRANS_LINES} transmission_efficiency[z1, z] * (existing_transmission[z1, z] + sum {(z1, z, v, h) in TRANS_VINTAGE_HOURS} InstallTrans[z1, z, v])),
  (sum {(z, z2) in TRANS_LINES} (transmission_efficiency[z, z2] * DispatchTransTo[z, z2, h] - DispatchTransFrom[z, z2, h]))
  - (sum {(z1, z) in TRANS_LINES} (DispatchTransTo[z1, z, h] - transmission_efficiency[z1, z] * DispatchTransFrom[z1, z, h])),
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# transmission losses 
# (assigned to originating zone, so that generation+transmission = load+losses in each zone)
printf {z in LOAD_ZONES, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", "Transmission Losses", "na", 0, 0, 0, "na",
  (sum {(z, z2) in TRANS_LINES} ((1 - transmission_efficiency[z, z2]) * DispatchTransFrom[z, z2, h]))
  + (sum {(z1, z) in TRANS_LINES} ((1 - transmission_efficiency[z1, z]) * DispatchTransTo[z1, z, h])),
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);

# system load
printf {z in LOAD_ZONES, h in HOURS, p in PERIODS: period[h]=p} 
  "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
  scenario_name, carbon_cost, p, z, date[h], h, "na", "Fixed Load", "na", 0, 0, 0, "na",
  system_load[z, h],
  0, hours_in_sample[h], 0, 
  0, 0, 0
  >> (outfile);
# printf {z in LOAD_ZONES, h in HOURS, p in PERIODS: period[h]=p} 
#   "%s,%f,%d,%s,%d,%d,%s,%s,%s,%d,%d,%d,%s,%f,%f,%d,%f,%f,%f,%f\n",
#   scenario_name, carbon_cost, p, z, date[h], h, "na", "Dispatched Load", "na", 0, 0, 0, "na",
#   DispatchSystemLoad[z, h],
#   0, hours_in_sample[h], 0, 
#   0, 0, 0
#   >> (outfile);

close (outfile);



#######################
# store detailed transmission info in standardized, MW terms

let outfile := "results/transmission_" & carbon_cost & ".csv";
printf "scenario_name,carbon_cost,period,load_area_receive,load_area_from,date,hour,power_sent,hours_in_sample\n"
  > (outfile);


# detailed imports
printf {(z, z2) in TRANS_LINES, h in HOURS, p in PERIODS: period[h]=p and DispatchTransTo[z, z2, h] > 0.001} 
  "%s,%f,%d,%s,%s,%d,%d,%f,%d\n",
  scenario_name, carbon_cost, p, z, z2, date[h], h, 
  DispatchTransTo[z, z2, h],
  hours_in_sample[h]
  >> (outfile);


# detailed exports
printf {(z, z2) in TRANS_LINES, h in HOURS, p in PERIODS: period[h]=p and DispatchTransFrom[z, z2, h] > 0.001} 
  "%s,%f,%d,%s,%s,%d,%d,%f,%d\n",
  scenario_name, carbon_cost, p, z, z2, date[h], h, 
  DispatchTransFrom[z, z2, h],
  hours_in_sample[h]
  >> (outfile);


#  (sum {(z, z2) in TRANS_LINES} (transmission_efficiency[z, z2] * DispatchTransTo[z, z2, h] - DispatchTransFrom[z, z2, h]))
#  - (sum {(z1, z) in TRANS_LINES} (DispatchTransTo[z1, z, h] - transmission_efficiency[z1, z] * DispatchTransFrom[z1, z, h])),

close (outfile);


#######################
# store all gen/trans capacity data in standardized, MW terms
# (these are quoted as total capacity installed up through each study period)

let outfile := "results/gen_cap_" & carbon_cost & ".csv";
printf "scenario_name,carbon_cost,period,load_area,technology,site,orientation,new,baseload,cogen,fuel,capacity,fixed_cost\n" > (outfile);

# new projects (either intermittent or dispatchable)
# (this can be changed to just dispatchable or intermittent by using PROJ_DISPATCH or PROJ_INTERMITTENT instead of PROJECTS)
printf {(z, t, s, o) in PROJECTS, p in PERIODS: (max {(z, t, s, o, v) in PROJECT_VINTAGES} InstallGen[z, t, s, o, v]) > 0}
  "%s,%f,%d,%s,%s,%s,%s,%d,%d,%d,%s,%f,%f\n",
  scenario_name, carbon_cost, p, z, t, s, o, 1, 0, 0, fuel[t],
  sum {(z, t, s, o, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, s, o, v],
  sum {(z, t, s, o, v) in PROJECT_VINTAGES: v <= p < project_end_year[t, v]} InstallGen[z, t, s, o, v]
    * (capital_cost_annual_payment[z,t,s,o,v] + fixed_cost_proj[z,t,v]) * (1-(1/(1+discount_rate)^(years_per_period)))/discount_rate
  >> (outfile);

# existing plants (either baseload or dispatchable)
# note: they're only counted as "capacity" if they are operable during this period
# and baseload plants are assumed to be operable only up to 1-ep_scheduled_outage_rate
printf {(z, e, p) in EP_PERIODS}
  "%s,%f,%d,%s,%s,%s,%s,%d,%d,%d,%s,%f,%f\n",
  scenario_name, carbon_cost, p, z, "na", e, "na", 0, ep_baseload[z, e], ep_cogen[z, e], ep_fuel[z, e],
  OperateEPDuringYear[z, e, p] * ep_size_mw[z, e] 
    * if ep_baseload[z, e] then (1-ep_scheduled_outage_rate[z, e]) else 1,
  OperateEPDuringYear[z, e, p] * ep_size_mw[z, e] * ep_fixed_cost[z, e, p] * (1+discount_rate)^(p-base_year)
  + ep_size_mw[z, e] * ep_capital_cost_annual_payment[z, e] * (1-(1/(1+discount_rate)^(years_per_period)))/discount_rate
  >> (outfile);

# hydro plants (pumped or simple)
# note: capacity is defined as the maximum possible output on any date in the period
# currently assumed to have no fixed cost; fix this later!
printf {(z, s) in PROJ_HYDRO, p in PERIODS}
  "%s,%f,%d,%s,%s,%s,%s,%d,%d,%d,%s,%f,%f\n",
  scenario_name, carbon_cost, p, z, "na", s, "na", 0, 0, 0, "Hydro",
  max {d in DATES, h in HOURS: date[h] = d and period[h] = p} max_hydro_flow[z, s, d],
  0
  >> (outfile);

## existing transmission capacity into each zone
## note: maximum delivery into each zone is reduced by transmission inefficiency
#printf {z in LOAD_ZONES, p in PERIODS}
#  "%d,%d,%s,%s,%s,%s,%d,%d,%d,%s,%f\n",
#  carbon_cost, p, z, "na", "Transmission", "na", 0, 0, 0, "na",
#    sum {(z, z2) in TRANS_LINES} transmission_efficiency[z, z2] * existing_transmission[z, z2]
#    + sum {(z1, z) in TRANS_LINES} transmission_efficiency[z1, z] * existing_transmission[z1, z]
#  >> (outfile);
#
## new transmission capacity into each zone
#printf {z in LOAD_ZONES, p in PERIODS}
#  "%d,%d,%s,%s,%s,%s,%d,%d,%d,%s,%f\n",
#  carbon_cost, p, z, "na", "Transmission", "na", 1, 0, 0, "na",
#    sum {(z, z2) in TRANS_LINES, v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} transmission_efficiency[z, z2] * InstallTrans[z, z2, v]
#    + sum {(z1, z) in TRANS_LINES, v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} transmission_efficiency[z1, z] * InstallTrans[z1, z, v]
#  >> (outfile);

close (outfile);

########################
# store all trans capacity between zones
let outfile := "results/trans_cap_" & carbon_cost & ".csv";
printf "scenario_name,carbon_cost,period,start,end,tid,new,trans_mw,fixed_cost\n" > (outfile);

# existing lines 
# TODO: update this if the main model is changed to retire existing lines when they reach transmission_max_age_years
# TODO: switch this to record the bidirectional capacities, instead of averaging them together
printf {(z1, z2) in TRANS_LINES, p in PERIODS}:
  '%s,%f,%d,"%s","%s",%d,%d,%f,%f\n',
  scenario_name, carbon_cost, p, z1, z2, tid[z1, z2], 0, (existing_transmission_from[z1, z2]+existing_transmission_to[z1, z2])/2,
  ((existing_transmission_from[z1, z2]+existing_transmission_to[z1, z2])/2) 
    * transmission_annual_payment[z1, z2, first(PERIODS)] * (1-(1/(1+discount_rate)^(years_per_period)))/discount_rate
  >> (outfile);

# new lines
printf {(z1, z2) in TRANS_LINES, p in PERIODS}:
  '%s,%f,%d,"%s","%s",%d,%d,%f,%f\n',
  scenario_name, carbon_cost, p, z1, z2, tid[z1, z2], 1, sum {v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} InstallTrans[z1, z2, v],
  (sum {v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} InstallTrans[z1, z2, v] * transmission_annual_payment[z1, z2, v])
     * (1-(1/(1+discount_rate)^(years_per_period)))/discount_rate
  >> (outfile);

close (outfile);


########################
# store local T&D capacity within each zone
let outfile := "results/local_td_cap_" & carbon_cost & ".csv";
printf "scenario_name,carbon_cost,period,load_area,local_td_mw,fixed_cost\n" > (outfile);

printf {p in PERIODS, z in LOAD_ZONES}:
  '%s,%f,%d,%s,%f,%f\n',
  scenario_name, carbon_cost, p, z, 
  sum {v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} InstallLocalTD[z, v],
  (sum {v in VINTAGE_YEARS: v <= p < transmission_end_year[v]} InstallLocalTD[z, v])
    * local_td_annual_payment_per_mw * (1-(1/(1+discount_rate)^(years_per_period)))/discount_rate
  >> (outfile);

close (outfile);



  ########################## End code from record_results.run
printf "time taken to store results: %d seconds\n", time()-curtime;


}